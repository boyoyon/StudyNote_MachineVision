<!doctype html>
<html lang="ja">
    <head>
        <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
        <meta charset="utf-8" />
        <title>フィルタ処理</title>
        <style type="text/css">
            p
            {
                padding-left: 2em;
            }
            .margin-large
            {
                margin-left: 30px;
            }
           .margin-abstract {
               margin-left: 60px; /* 左マージンを広くする */
               margin-right: 60px; /* 右マージンを広くする */
           }
        </style>
    <style>
        .two-columns {
            display: flex;
            flex-direction: row;
            gap: 20px; /* 列間のスペース */
        }
        .column {
            flex: 1; /* 各列が均等に幅を取る */
        }
    </style>
<style>
.three-columns {
  display: flex;
  gap: 10px; /* 列間の余白を設定 */
}
.column {
  flex: 1; /* 各列の幅を均等にする */
  padding: 10px; /* 内側の余白を設定 */
}
</style>
    <style>
        .styleRef { 
            text-indent: -40px; /* 最初の行の字下げを逆方向に */
            margin-left: 10px; /* 2行目以降の字下げを調整 */
            ul {
                  list-style-type: none; /* 箇条書き記号を非表示 */
                  padding-left: 40px; /* 全体の左余白 */
            }
            li {
            }
        }
    </style>
    <style>
        .styleBullet { 
            text-indent: -20px; /* 最初の行の字下げを逆方向に */
            margin-left: 30px; /* 2行目以降の字下げを調整 */
            ul {
                  list-style-type: none; /* 箇条書き記号を非表示 */
                  padding-left: 0px; /* 全体の左余白 */
            }
            li {
            }
        }
    </style>
    <style>
            ol
            {
                margin-left: 30px;
            }
            ul
            {
                margin-left: 30px;
            }
    </style>
    </head>
    <body>
        <h1><center>４章 フィルタ処理</center></h1>
<p>
カメラやその他の画像処理システムにより画像が取り込まれても、ビジョン・システムはそれを直接使えない事が多い。画像は輝度のランダムな変動や、照明の変動で汚されている事もあるし、コントラストが不足している事もあり、ビジョン・システムの初期工程で処理しなければならない。
</p>
<p>
  本章ではこれらの望ましくない特性を除去する事を狙った画像強調の方法を述べる。この章はヒストグラム修正で始まり、離散線形システムと周波数解析の簡単な検討と様々なフィルタ処理の適用が続く。ガウシアン平滑フィルタは詳しく扱う。
</p>
<h2>4.1  ヒストグラム補正</h2>
<p>
多くの画像は偏った分布のグレイ値を持つ。図4.1に示すコントラストの乏しい画像の様に、グレイ値の全てが狭い範囲にある画像をよく見かける。ヒストグラム均等化(equalization)はグレイ値を均等に再分配する事によりこの様な画像のコントラストを増す方法である。この工程はしきい値選択手法をより効率的なものにする。一般にヒストグラム補正は画像の主観的品質を高め、人間が画像を見る事を意図している場合には役立つ。
</p>
<center><img src="images/fig4_1.png"></center>
<p>
<center>図4.1　ビジョン・システムではそのまま使用できないコントラストの乏しい画像</center>
</p>
<p>
ヒストグラム均等化の簡単な例はスケーリングである。範囲 \([a,b]\) のピクセルは範囲 \([z_1,z_k]\) を充たす様に広げられる。元の範囲内のピクセル値 \(z\) を新しい範囲内のピクセル値 \(z'\) に写像する式は以下の様になる。
</p>
<center><img src="images/fig4_0.png"></center>
<p>
\[
\begin{align}
z^\prime &= \frac{z_k-z_l}{b-a}(z-a)+z_l \\
\\
&=\frac{z_k-z_l}{b-a}z+\frac{-z_k\,a+\bcancel{z_l\,a}}{b-a}+\frac{z_l\,b-\bcancel{z_l\,a}}{b-a} \\
\\
&=\frac{z_k-z_l}{b-a}z+\frac{z_l\,b-z_k\,a}{b-a}
\tag{4.1}
\end{align}
\]
この手法の問題は、この式に従ってヒストグラムを広げた場合、結果のヒストグラムにギャップが出来る事である(図4.2参照)。もっと良い方法は出力ヒストグラム内の全てのビンを連続的に満たしながらヒストグラムを広げる。
</p>
<center><img src="images/fig4_2.png"></center>
<p>
図4.2　オリジナルの画像はグレイ値が非常に狭い範囲にあるのでコントラストが乏しい。ヒストグラム・スケーリングはコントラストを改善するが最終ヒストグラムにギャップが残る。上段：オリジナル画像とそのヒストグラム。下段：ヒストグラム・スケーリング後の画像とヒストグラム
</p>
<p>
  希望するヒストグラムが前もって判っているならば以下の方法を使う事が出来る。\(p_i\) を元のヒストグラムのレベル \(z_i\) のピクセル数、\(q_i\) を希望するヒストグラム内のレベル \(z_i\) のピクセル数とする。元のヒストグラムの左端から始めて、以下の様なグレイ値を探す。
\[
\sum_{i=1}^{k_1-1} p_i \leq q_1\lt \sum_{i=1}^{k_1} p_i \tag{4.2}
\]
レベル \(z_1,z_2,･･･,z_{k_1－1}\) のピクセルは新しい画像ではレベル \(z1\) に写像される。次に以下の様になるグレイ値 \(k_2\) を探す。
\[
\sum_{i=1}^{k2-1} p_i \leq q_1 \lt \sum_{i=1}^{k_2} p_i \tag{4.3}
\]
ピクセル値の次の範囲 \(z_{k_1},･･･,z_{k_2－1}\) はレベル \(z_2\) に写像される。この手続きは元のヒストグラムの全てのグレイ値が含まれるまで繰り返される。この手法の結果を図4.3に示す。
</p>
<p>
  ヒストグラムが広げる場合、元の画像では同じグレイ値だったピクセルを新しい画像では異なるグレイ値に広げなければならなくなるかもしれない。最も簡単な手続きは入力ピクセルに割り当てる出力値をランダムに選ぶ方法である。区間 \([0,1)\) の数を生成する一様ランダム数生成器を使って、ピクセルを \(n\) 個の出力レベル \(q_k , q_{k＋1},･･･,q_{k＋n－1}\) に広げるとしよう。出力ピクセル数は以下の式を使ってランダム数 \(r\) から計算できる。
\[
k+\lfloor n*r \rfloor \tag{4.4}
\]
言い換えると各判断で、ランダム数を取り出し、区間内の出力値に数を掛け、近い整数値に切り下げ、こうして求めたオフセットを最小インデックスに加える。
</p>
<center><img src="images/fig4_3.png"></center>
<p>
図4.3　オリジナルの画像はグレイ値が非常に狭い範囲にあるのでコントラストが乏しい。ヒストグラム均等化はグレイ値を均一な分布にマッピングすることでコントラストを改善する。とは言え、この方法でも、入力画像の同じグレイ値を持つピクセルを出力画像のいくつかのグレイ値に広げない限り、まだ最終ヒストグラムにギャップが残る。上段：オリジナル画像とそのヒストグラム。下段：ヒストグラム均等化後の画像とヒストグラム
</p>
<p>
(ここから蛇足)<br>
<br>
　難しく書いてあるが、ヒストグラムを累積したものが直線になるように輝度値を変更すると, 明るい方にも暗い方にも偏っていない画像ができる(Histogram Equalization) 。
</p>
<center><img src="images/fig4_02.png"></center>
<p>
実際にはやり過ぎになる場合があるので、ヒストグラムをクリッピングしたり
</p>
<center><img src="images/fig4_03.png"></center>
<p>
画像をタイル状に分割してタイル毎にヒストグラム均等化の輝度補正量を求め、補正量をバイリニア補間したりする(CLAHE: Contrast Limited Adaptive Histogram Equalization)。
</p>
<center><img src="images/fig4_04.png"></center>
<p>
(ここまで蛇足)<br>
</p>
<h2>4.2  線形システム</h2>
<p>
多くの画像処理操作は線形システムとしてモデル化できる。
</p>
<center><img src="images/fig4_05.png"></center>
<p>
線形システムに対して入力が原点を中心としたインパルス \(δ(x,y)\) の場合、出力 \(g(x,y)\) はインパルス応答になる。更にシステムが入力の位置に関係なく同じ応答であるならば、空間不変(space invariant)システムと呼ばれる。
</p>
<center><img src="images/fig4_06.png"></center>
<p>
線形空間不変(LSI)システムは以下の様に、そのインパルス応答により完全に記述できる。
</p>
<center><img src="images/fig4_07.png"></center>
<p>
ここで \(f(x, y),h(x, y)\) はそれぞれ入力画像､出力画像である。上のシステムは[線形性の定義により]以下の関係を満たさなければならない。
\[
a\cdot f_1(x,y)+b\cdot f_2(x,y) \Rightarrow a\cdot h_1(x,y)+b\cdot h_2(x,y)
\]
ここで \(f_1(x,y),f_2(x,y)\) は入力画像であり \(h_1(x,y),h_2(x,y)\) は \(f_1,f_2\) に対応する出力画像、\(a,b\) は定数係数である。
</p>
<p>
　この様なシステムに対しては出力 \(h(x,y)\) は \(f(x,y)\) とインパルス応答 \(g(x,y)\) の畳み込みになり。それは以下の様に定義される。
\[
\begin{align}
h(x,y) &= f(x,y) * g(x,y) \\
\\
&=\int_{-\infty}^\infty\int_{-\infty}^\infty f(x',y')g(x-x',y-y')dx'dy' \tag{4.5}
\end{align}
\]
離散関数に対しては以下の様になる。
\[
\begin{align}
h[i,j] &=f[i,j]*g[i,j] \\
\\
&=\sum_{k-1}^n\sum_{l-1}^m f[k,l]g[i-k,j-l] \tag{4.6}
\end{align}
\]
</p>
<p>
  fとhが画像の場合には畳み込みは画像ピクセルの荷重和の計算になる。インパルス応答g[i,j]は畳み込みマスクと呼ばれる。画像内の各ピクセル[i,j]に対して値h[i,j]は、畳み込みマスクをピクセル[i,j]に移動し、畳み込みマスクの値を対応する[i,j]の近傍ピクセルの重みとして荷重和をとることで計算される。この工程は3×3マスクを使って図4.4で図説されている。
</p>
<center><img src="images/fig4_4.png"></center>
<p>
\[
h[i,j]=A\cdot p_1+B\cdot p_2+C\cdot p_3+D\cdot p_4+E\cdot p_5+F\cdot p_6+G\cdot p_7+H\cdot p_8+I\cdot p_9
\]
図4.4　\(3×3\) 畳み込みマスクの例。畳み込みマスクの原点は位置Eに対応し、重み \(A,B,･･･,I\) は \(g[-k,-l]\) の値である。ここで \(k, l\) は \(-1,0,+1\)
</p>
<p>
  畳み込みは線形である。なぜなら任意の定数 \(a1,a2\) に対して
\[
g[i, j]*\{a_1･h_1[i, j]+a_2･h_2[i, j]\}＝a_1\{g[i, j]*h_1[i, j]\}+a_2\{g[i, j]*h_2[i, j]\}
\]
が成り立つからである。言い換えると和の畳み込みは畳み込みの和になり、[輝度値を]定数倍した画像の畳み込みは畳み込みの定数倍になる。畳み込みは空間的に不変の操作である。なぜなら画像全体に渡って同じフィルタ荷重を使うからである。しかし空間的に変化するフィルタでは画像の場所によって異なるフィルタ荷重を必要とする。
</p>
<p>
<strong>フーリエ変換</strong><br>
\(n×m\) の画像は以下の様に周波数成分によって表現する事が出来る。
\[
f[k,l]=\frac{1}{4\pi^2}\int_{-\pi}^\pi\int_{-\pi}^\pi F(u,v)e^{jku}e^{jlv}du\,dv \tag{4.7}
\]
ここで \(F(u,v)\) は画像のフーリエ変換である。フーリエ変換は各周波数成分の振幅と位相を符号化し、以下の様に定義される。
\[
\begin{align}
F(u,v) &=\mathfrak F\{f[k,l]\} \\
\\
&=\sum_{k=1}^n\sum_{l=1}^m f[k,l]e^{-jku}e^{-jlv} \tag{4.8}
\end{align}
\]
ここで \(\mathfrak F\)  はフーリエ変換操作を表す。\((u,v)\) 平面の原点に近い値はフーリエ変換の低周波成分と呼ばれ、原点から離れている値は高周波成分と呼ばれる。\(F(u,v)\) は連続関数である事に注意して欲しい。
</p>
<p>
  画像領域での畳み込みは空間周波数領域での乗算に対応する。従って大きなフィルタを使った畳み込みは通常画像領域では高くつく処理であるが、高速フーリエ変換を使って効率的に実現できる。これは多くの画像処理アプリケーションで重要なテクニックである。しかしマシンビジョンではたいていのアルゴリズムは非線形か、または空間的に不変ではないので高速フーリエ変換は使わない。ビジョンアルゴリズムが線形空間不変システムでモデル化できる場合はたいていフィルタサイズが小さく、高速フーリエ変換のメリットは小さいかほとんど無い。従って次節で述べる平滑フィルタの様な線形フィルタは通常画像領域での畳み込みで実現される。
</p>
<h2>4.3  線形フィルタ</h2>
<p>
前に述べた様に画像はノイズと呼ばれる輝度のランダムな変動で汚されている事が多い。ノイズの一般的なタイプとしてはごま塩ノイズ(salt and pepper noise)、インパルス・ノイズ、ガウシアン・ノイズ等がある。ごま塩ノイズはランダムな頻度の白と黒両方の輝度を含む。これに対してインパルス・ノイズはランダムな頻度の白の輝度値しか含まない。ガウシアン・ノイズはこれらと異なり、ガウス分布・正規分布から引き出される輝度値の分布を含んでおり、カメラ電子機器によるノイズの様な様々な種類のセンサーノイズを非常にうまくモデル化している(図4.5参照)。
</p>
<p>
  線形平滑フィルタはガウシアン・ノイズを除去するのに適したフィルタであり、たいていの場合他の種類のノイズに対しても適している。線形フィルタは一連のウィンドウの中のピクセルの荷重和を使って実現される。通常は各ウィンドウで同じパタンの重みが使われる。つまり線形フィルタは空間不変の事が多く、畳み込みマスクを使って実現できる。画像の異なる場所で異なるフィルタ荷重を使うものの依然、荷重和で実現される場合、線形フィルタは空間依存である。ピクセルの荷重和ではないフィルタは全て非線形フィルタである。非線形フィルタは画像内の位置に依らず同じ計算で実行できる空間不変の事もあれば、空間依存の事もある。4.4節で紹介するメディアン・フィルタは空間不変非線形フィルタである。
</p>
<center><img src="images/fig4_5.png"></center>
<p>
図4.5　ごま塩ノイズ、インパルス・ノイズ、ガウシアン・ノイズで汚れた画像例。<br>
(a)(b)：オリジナル画像。(c)ごま塩ノイズ。(d)インパルス・ノイズ。(e)ガウシアン・ノイズ
</p>
<p>
<strong>平均フィルタ</strong><br>
最も簡単な線形フィルタは、各ピクセルの値を局所近傍全ての値の平均で置き換えると言う局所平均操作で実現される。
\[
h[i,j]=\frac{1}{M}\sum_{(k,l)\in N} f[k,l] \tag{4.9}
\]
ここで \(M\) は近傍 \(N\) のピクセルの総数である。例えば \([i,j]\) を中心とする \(3×3\) 近傍を取ると以下の様になる。
\[
h[i,j]=\frac{1}{9}\sum_{k=i-1}^{i+1}\sum_{l=j-1}^{j+1} f[k,l] \tag{4.10}
\]
式4.6と比較して欲しい。畳み込みマスクの全ての \([i,j]\) で \(g[i,j]＝1/9\) とすると式4.6の畳み込み操作は上に示した局所平均操作になる。この結果は、平均フィルタは畳み込みマスク内を等しい荷重にした畳み込み操作として実現できる事を示している(図4.6参照)。実際多くの画像処理操作が畳み込みを使って実現できる事を後で見る。
</p>
<center><img src="images/fig4_6.png"></center>
<p>
<center>図4.6　3×3近傍を使った平均フィルタを説明する例</center>
</p>
<p>
近傍のサイズNがフィルタ量を制御している。近傍を広くするほど、つまり畳み込みマスクを大きくするほどフィルタの度合いは大きくなる。ノイズ除去の量が多くなる事のトレードオフとして、大きなフィルタ量は画像の細部を失う。様々なサイズの平均フィルタの結果を図4.7に示す
</p>
<center><img src="images/fig4_7.png"></center>
<p>
<center>図4.7　図4.5のノイズ画像に3×3、5×5、7×7の平均フィルタ適用結果</center>
</p>
<p>
  線形平滑フィルタを設計する場合、フィルタ荷重はメインローブ(lobe：極大部分)と呼ばれる単一ピークを持ち、水平・垂直に対称となる様に選ぶべきである。\(3×3\) 平滑フィルタ用の荷重の典型的なパタンは以下の様なものである。
\[
\begin{array}{|c|c|c|}
\hline
\frac{1}{16} & \frac{1}{8} & \frac{1}{16} \\
\hline
\frac{1}{8} & \frac{1}{4} & \frac{1}{8} \\
\hline
\frac{1}{16} & \frac{1}{8} & \frac{1}{16} \\
\hline
\end{array}
\]
</p>
<p>
線形平滑フィルタは高周波成分を取り除き、画像の鮮明な細部は失われる。例えば階段状の変化はなだらかな変化にぼやけ、変化[位置]を正確に突き止める能力が犠牲になる。空間的に変化するフィルタは画像内の比較的均一なところでは平滑化量を多くし、画像内の鋭く変化しているところでは平滑化を抑える様に荷重を調整する事が出来る。上に示したマスクを使った線形平滑フィルタの結果を図4.8に示す。
</p>
<center><img src="images/fig4_8.png"></center>
<p>
<center>図4.8　ガウシアン・ノイズで汚染された画像に線形平滑フィルタを適用した結果。</center>
<center>左：ノイズ画像。右：平滑化された画像</center>
</p>
<h2>4.4  メディアン・フィルタ</h2>
<p>
局所平均操作の主な問題点は、画像内の鋭い不連続をぼかしやすい事である。もう一つの手法は各ピクセルを、局所近傍内のグレイ値の中央値(median)で置き換えると言うものである。この手法を使ったフィルタをメディアン・フィルタと呼ぶ。
</p>
<p>
  メディアン・フィルタは近傍内の典型値と大きく異なる値に依存しないので、ごま塩ノイズやインパルス・ノイズの除去に非常に効果的である。メディアン・フィルタは線形フィルタと同じ形式の一連の画像ウィンドウで動作する。しかし処理は荷重和ではない。例えば3×3のウィンドウを使い、[i, j]を中心とする各ウィンドウ内のピクセル値の中央値を計算する。
<div class="styleBullet">
<ul>
<li>1. ピクセルをグレイレベルの昇順に並べ替える</li>
<li>2. ピクセル[i, j]の新しい値として中央のピクセルの値を選ぶ</li>
</ul>
</div>
</p>
<p>
この処理を図4.9で図説している。一般に中央値の計算には奇数サイズの近傍が使われる。
</p>
<center><img src="images/fig4_9.png"></center>
<p>
<center>図4.9　3×3近傍を使ったメディアン・フィルタを説明する例</center>
</p>
<p>
しかしピクセル数が偶数でも、中央値としてソート後の中央の2ピクセルの平均を使えば良い。色々なサイズのメディアン・フィルタの結果を図4.10に示す。
</p>
<center><img src="images/fig4_10.png"></center>
<p>
<center>図4.10　図4.5のノイズのある画像に \(3×3,5×5,7×7\) メディアンフィルタを適用した結果</center> 
</p>
<h2>4.5  ガウシアン平滑フィルタ</h2>
<p>
ガウシアン・フィルタは、荷重をガウス関数の形に従って選んだ線形平滑フィルタのクラスである。ガウシアン平滑フィルタは正規分布を成すノイズを除去するのに非常に適している。1次元の0平均ガウス関数は以下である。
\[
g(x)=e^{-\frac{x^2}{2\sigma^2}} \tag{4.11}
\]
ここでガウシアン広がりパラメータ \(σ\) がガウス関数の幅を決める。画像処理では2次元0平均の離散ガウス関数
\[
g[i,j]=e^{-\frac{(i^2+j^2)}{2\sigma^2}} \tag{4.12}
\]
が平滑フィルタとして使われる。この関数のプロットを図4.11に示す。
</p>
<center><img src="images/fig4_11.png"></center>
<p>
<center>図4.11　平均0の2次元ガウシアン関数</center>
</p>
<p>
ガウス関数はビジョン処理の初期で特に有用となる特性を5つ持っている。これらの特性はガウシアン平滑フィルタが空間領域、周波数領域の両方の観点から効果的なローパスフィルタであり、効率的に実装出来、実際のビジョン応用で技術者が効果的に使う事が出来る事を示している。5つの特性を以下に要約する。詳しい説明は本節の後で行う。
<div class="styleBullet">
<ul>
<li>1. 2次元のガウス関数は回転対称である。これはフィルタの実行する平滑量が全ての方向で等しい事を意味する。一般に画像内のエッジは予め判っている特定の方向を向いていると言う事はない。従って先験的に他の方向よりも多くある方向に平滑化する理由はない。回転対称と言う特性はガウシアン平滑フィルタが後のエッジ検出をいかなる方向にも偏らせない事を意味する。</li>
<br>
<li>2. ガウス関数は1つのローブ(極大部分)しか持たない。これはガウシアン・フィルタが各ピクセルを、中心ピクセルからの距離とともに単調減少する重みによる近傍ピクセルとの荷重和で置き換える事を意味している。エッジは画像内の局所的な特徴なのでこの性質は重要であり、離れているピクセルにもっと大きな重みを与える平滑操作はその特徴を歪ませる。</li>
<br>
<li>3. ガウス関数のフーリエ変換は周波数スペクトルでも単一のローブしか持たない。この特性は以下に示すガウス関数のフーリエ変換はガウス関数であると言う事実の直接的な系である。画像は望ましくない高周波信号(ノイズや細かいテクスチャ)で汚される事が多い。エッジのような望まれる画像特徴は低周波と高周波の両方の成分を持つ。ガウス関数は望ましくない高周波信号の寄与により平滑化された画像を汚さないであろう事と、望まれる信号の多くを残すであろう事を意味している。</li>
<br>
<li>4. ガウシアン・フィルタの幅、つまり平滑量は \(σ\) でパラメータ化されており、\(σ\) と平滑量の間の関係は非常に単純である。大きい \(σ\) は広いガウシアン・フィルタを意味し平滑量も大きい。技術者は望ましい画像特徴のぼかしすぎ(過度の平滑化)と、ノイズや細かいテクスチャによる平滑化画像の変動しすぎ(平滑化不足)の間の妥協を実現する平滑量を調整出来る。</li>
<br>
<li>5. ガウス関数は可分なので大きなガウシアン・フィルタは非常に効率的に実現出来る。2次元のガウシアン畳み込みは先ず1次元のガウス関数で画像をたたみ込みし、その結果を先程とは直交した向きの1次元ガウシアンで畳み込みを行う事で実行出来る。従って2Dガウシアン・フィルタで必要な計算量は2次的でははく、フィルタマスク幅の1次で増える。</li>
</ul>
</div>
</p>
<h3>4.5.1  回転対称性</h3>
<p>
ガウス関数の回転対称性は関数を直交座標から極座標に変換する事で示す事が出来る。2次元ガウス関数は以下の式だった事を思い出そう。
\[
g[i,j]=e^{-\frac{(i^2+j^2)}{2\sigma^2}} \tag{4.13}
\]
極座標の半径は \(r^2=i^2+j^2\) で与えられるので、極座標のガウス関数
\[
g[i,j]=e-{-\frac{r^2}{2\sigma^2}} \tag{4.14}
\]
が偏角 \(θ\) に依存しない事、従って回転対称である事が簡単に判る。ある特定の方向に多く平滑化しなければならない事が予め分かっている応用で必要とされるならば回転非対称なガウス関数を構成する事も可能である。回転非対称なガウス関数の式はWozencraftとJacobsが与えた。彼らは通信チャネルの確率解析に利用した。
</p>
<h3>4.5.2  フーリエ変換特性</h3>
<p>
ガウス関数はフーリエ変換もまたガウス関数になると言う注目すべき特性を持っている。ガウス関数のフーリエ変換は実関数なのでフーリエ変換は自身の振幅になる。ガウス関数のフーリエ変換は以下の様に計算される。
\[
\begin{align}
\mathfrak F\{g(x)\} &= \int_{^\infty}^\infty g(x)e^{-j\omega x}dx \tag{4.15} \\
\\
&=\int_{-\infty}^\infty e^{-\frac{x^2}{2\sigma^2}}e^{-j\omega x}dx \tag{4.16} \\
\\
&=\int_{-\infty}^\infty e^{-\frac{x^2}{2\sigma^2}}(\cos\omega x+j\sin\omega x)dx \tag{4.17} \\
\\
&=\int_{-\infty}^\infty e^{-\frac{x^2}{2\sigma^2}}\cos\omega x\,dx+j\int_{\infty}^\infty e^{-\frac{x^2}{2\sigma^2}}\sin\omega x\,dx \tag{4.18}
\end{align}
\]
ガウス関数は対称関数でサイン関数は反対称なので第二項の被積分関数は反対称になる。従って積分は0でなければならずフーリエ変換は以下の様に簡単化される。
\[
\begin{align}
\mathfrak F\{g(x)\} &=\int_{-\infty}^\infty e^{-\frac{x^2}{2\sigma^2}}\cos\omega x\,dx \tag{4.19}
\\
&=\sqrt{2\pi}\sigma e^{-\frac{\omega^2}{2\nu^2}},　\nu^2=\frac{1}{\sigma^2} \tag{4.20}
\end{align}
\]
空間周波数パラメータは \(ω\)、周波数領域でのガウス関数の広がりは \(\nu\) で、これは空間領域の広がりパラメータ \(σ\) の逆数である。これは空間領域で狭いガウス関数は広いスペクトルを持ち、空間領域で広いガウス関数は狭いスペクトルを持つ事を意味する。この特性はガウシアン・フィルタのノイズ抑圧能力と関連する。空間領域で狭いガウシアン・フィルタは平滑化量が少なく、周波数領域でのスペクトルは広い帯域幅を持ち高周波のノイズやテクスチャの多くを通過させる。空間領域でガウス関数の幅を広げるに従ってガウス関数が実行する平滑量は増え、周波数領域ではガウス関数は狭くなり高周波ノイズやテクスチャは通りにくくなる。空間領域でのガウス関数の幅と周波数領域でのスペクトルの幅の関係のこの単純さのおかげで実際の設計状況で使い勝手が良い。ガウス関数のフーリエ変換双対性は空間領域の単一ローブ特性がなぜ周波数領域にも持ち込まれるかも説明する。
</p>
<h3>4.5.3  ガウス関数可分性(分離可能性)</h3>
<p>
ガスシアンフィルタの可分性は簡単に証明出来る。
\[
\begin{align}
g[i,j]*f[i,j] &= \sum_{k=1}^m\sum_{l=1}^n g[k,l]f[i-k,j-l] \tag{4.21} \\
\\
&=\sum_{k=1}^m\sum_{l=1}^n e^{-\frac{(k^2+l^2)}{2\sigma^2}}f[i-k,j-l] \tag{4.22} \\
\\
&=\sum_{k=1}^m e^{^\frac{k^2}{2\sigma^2}}\left\{\sum_{l=1}^n e^{-\frac{l^2}{2\sigma^2}}f[i-k,j-l]\right\} \tag{4.23}
\end{align}
\]
括弧内の和は入力画像 \(f[i, j]\) と垂直1次元ガウス関数の畳み込みである。この和の結果は垂直方向にぼかされた2次元画像であり、画像を水平方向にぼかす水平1次元ガウシアンとの2番目の畳み込みの入力となる(図4.12参照)。畳み込みは結合可能で可換なので畳み込みの順序は先ず水平畳み込みを実行し、水平畳み込みの結果に垂直畳み込みを実行すると言う様に入れ替える事が出来る。
</p>
<center><img src="images/fig4_12.png"></center>
<p>
<center>図4.12　ガウシアン畳み込みの可分性の例。</center>
<center>左：垂直マスクを使った畳み込み。右：水平マスクを使った畳み込み。</center>
<center>各マスクの原点は網掛けされていることに注意</center>
</p>
<p>
  この方法は2回の水平畳み込みと1つの水平畳み込みマスクを合成して実装出来る。入力 \(f[i, j]\) は先ず水平ガウシアンで畳み込まれ、結果を転置して一時配列に置く。一時配列は水平畳み込みで垂直畳み込みを実行するように同じ畳み込みコードの入力となる。2番目の畳み込みからの出力は正しい(元の)方向にデータが格納されるように再び転置される。この可分畳み込みの結果を図4.13に示す。
</p>
<center><img src="images/fig4_13.png"></center>
<p>
<center>図4.13　単一の水平畳み込みマスクを使った可分ガウシアン畳み込みの結果。</center>
<center>(a)オリジナルのノイズのある画像。</center>
<center>(b)水平ガウシアン畳み込みマスクを使った畳み込み結果。(c) (b)の転置。</center>
<center>(d)水平マスクを使った(c)の畳み込み。(e) (d)の転置。これが最終平滑画像</center>
</p>
<h3>4.5.4  ガウス関数の縦列</h3>
<p>
ガウシアンフィルタに関連した特性はガウス関数同士の畳み込みが大きな \(σ\) に拡大されたガウス関数になると言う事である。これは1次元の場合で簡単に示す事が出来る。
\[
\begin{align}
g(x)*g(x) &= \int_{-\infty}^\infty e^{-\frac{\xi^2}{2\sigma^2}}e^{-\frac{(x-\xi)^2}{2\sigma^2}}\,d\xi \\
\\
&=\int_{-\infty}^\infty e-{-\frac{(\frac{x}{2}+\xi)^2}{2\sigma^2}}e^{-\frac{(\frac{x}{2}-\xi)^2}{2\sigma^2}}\,d\xi,\;\xi\to\xi+\frac{x}{2} \\
\\
&=\int_{-\infty}^\infty e^{-\frac{2\xi^2+\frac{x^2}{2}}{2\sigma^2}}\,d\xi \\
\\
&=e^{-\frac{x^2}{4\sigma^2}}\int_{-\infty}^\infty e^{-\frac{\xi^2}{\sigma^2}}\,d\xi \\
\\
&=\sqrt{\pi}\sigma e^{-\frac{x^2}{2(\sqrt{2}\sigma)^2}} \tag{4.24}
\end{align}
\]
広がり \(σ\) の2つのガウス関数の畳み込みの結果はガウシアンフィルタの面積で拡大された広がり のガウス関数になる。結果は2次元でも同様に満たされる。つまり画像が既にある広がり \(σ\) のガウス関数でフィルタを掛けられており、同じ画像に広がり のもっと広いガウス関数でフィルタをかけなければならない場合には、広いガウス関数で画像にフィルタを掛けるのではなく前の結果に広がり \(σ\) の同じガウス関数で再フィルタ処理する事で希望するフィルタ処理された画像が得られる事を意味している。これは画像の複数の平滑化バージョンを計算しなければならない状況では大幅な計算量の削減が行える事を意味している。同様の節約はσの値が異なるガウシアンフィルタの縦続でも得られる。
</p>
<h3>4.5.5  ガウシアンフィルタの設計</h3>
<p>
ガウス関数の優れた近似は二項展開係数から得られる。
\[
(1+x)^n=
\left(
\begin{array}{c}
n \\
0
\end{array}
\right)
+
\left(
\begin{array}{c}
n \\
1
\end{array}
\right)
x+
\left(
\begin{array}{c}
n \\
2
\end{array}
\right)
x^2+\cdots+
\left(
\begin{array}{c}
n \\
n
\end{array}
\right)
x^n \tag{4.25}
\]
言い換えると1次元のガウシアンフィルタの \(n\) 点近似としてパスカルの三角形の \(n\) 行を使う。例えば5点近似は以下の様になる。
\[
\begin{array}{|c|c|c|c|c|}
\hline
1 & 4 & 6 & 4 & 1\\
\hline
\end{array}
\]
これはパスカルの三角形の第5行に対応する。
</p>
<center><img src="images/fig4_08.png"></center>
<p>
このマスクは画像を水平方向に平滑化するために使う事が出来る。4.5.3節から2次元のガウシアンフィルタは1次元ガウス関数の畳み込みを水平方向、垂直方向と続ける事で実現出来た事を思い出して欲しい。また2回の畳み込みの間と最後に転置を行う事で単一の畳み込みまマスクのみを使って実現出来た事も思い出して欲しい。この近似を使ったガウシアンフィルタの結果を図4.14に示す。
</p>
<center><img src="images/fig4_14.png"></center>
<p>
<center>図4.14　パスカルの三角形の第5行を使ったガウシアン・フィルタの近似。</center>
<center>(a)オリジナルのノイズのある画像。(b)水平方向の平滑化後の画像。(c)垂直方向の平滑化後の最終画像</center>
</p>
<p>
  この技法はフィルタサイズがだいたい \(n=10\) までうまく動作する。これより大きいフィルタだと二項展開の係数がたいていのコンピュータで大きすぎる値になる。しかし任意の大きなガウシアンフィルタは小さいガウシアンフィルタを繰り返し適用する事で実現出来る。ガウシアンフィルタに対する二項近似の \(σ\) は二項係数へのガウス関数の最小二乗当て嵌めを使って計算される。
</p>
<p>
  ガウシアンフィルタを設計するもう一つの手法は離散ガウス分布から直接マスクの重みを計算すると言うものである。
\[
g[i,j]=ce^{-\frac{(i^2+j^2)}{2\sigma^2}} \tag{4.26}
\]
ここで \(c\) は正規化定数である。これを以下の様に書き直す。
\[
\frac{g[i,j]}{c}=e^{-\frac{(i^2+j^2)}{2\sigma^2}} \tag{4.27}
\]
そして値 \(σ^2\) を選ぶと核を得るために \(n×n\) のウィンドウに渡ってこれを評価する事が出来る。例えば \(σ^2＝2,n＝7\) と選ぶと上の式は以下の配列を生じる。
</p>
<center><img src="images/fig4_09.png"></center>
<p>
計算のし易さからフィルタ荷重を整数にしたい。そのために配列の隅の値を取り、その値が1となるような \(k\) を選ぶ。上の例を使うと以下の様になる。
\[
\frac{g[3,3]}{k}=e^{-\frac{(3^2+3^2)}{2.2}}=0.011\rightarrow k=\frac{g[3,3]}{0,011}=\frac{1.0}{0.011}=91
\]
残りの重みに \(k\) を掛けると以下が得られる。
</p>
<center><img src="images/fig4_010.png"></center>
<p>
これが最終的なガウシアンフィルタの畳み込みマスクである(図4.15も参照の事)。
</p>
<center><img src="images/fig4_15.png"></center>
<p>
<center>図4.15 7×7 ガウシアン・マスクの3D プロット</center>
</p>
<p>
しかし荷重の総和は1ではない。従って変化の無い領域が影響を受けないようにするためには、畳み込みを実行する際にマスク荷重の総和で出力ピクセルを正規化しなければならない。上の例では
\[
\sum_{i=-1}^3\sum_{j=^3}^3 g[i,j]=1115
\]
なので
\[
h[i,j]=\frac{1}{1115}(f[i,j]*g[i,j])
\]
ここで \(g[i, j]\) の荷重は全て整数である。上のマスクを使ったガウシアン平滑化の結果を図4.16に与える。そのほかの一般的なガウシアンフィルタマスクを図4.17に与える。
</p>
<center><img src="images/fig4_16.png"></center>
<p>
<center>図4.16　\(7×7\) ガウシアン・マスクを使った平滑化の結果。</center>
<center>(a)ガウシアン・ノイズで汚されたオリジナル画像。(b)平滑化された画像</center>
</p>
<center><img src="images/fig4_17_1.png"></center>
<p>
<center>7×7ガウシアンマスク</center><br>
</p>
<center><img src="images/fig4_17_2.png"></center>
<p>
<center>15×15ガウシアンマスク</center><br>
<center>図4.17  そのほかの一般的に使われるガウシアンマスク</center>
</p>
<h3>4.5.6  離散ガウシアンフィルタ</h3>
<p>
ガウシアンフィルタのサンプルや二項展開から得られた係数は離散ガウシアンフィルタを形作る。離散ガウシアンフィルタを畳み込むと結果は大きな離散ガウシアンフィルタになる。画像が \(n×n\) の離散ガウシアンフィルタで平滑化され、この中間結果が \(m×m\) の離散ガウシアンフィルタで平滑化されると、結果は元の画像を \((n+m－1)×(n+m－1)\) の離散ガウシアンフィルタで元の画像を平滑化したのと全く同じになる。言い換えるとパスカルの三角形の \(n\) 行と \(m\) 行を畳み込むとパスカルの三角形の \(n+m－1\) 行になる。
</p>
    </body>
</html>