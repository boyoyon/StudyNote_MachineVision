<!doctype html>
<html lang="ja">
    <head>
        <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
        <meta charset="utf-8" />
        <title>エッジ検出</title>
        <style type="text/css">
            p
            {
                padding-left: 2em;
            }
            .margin-large
            {
                margin-left: 30px;
            }
           .margin-abstract {
               margin-left: 60px; /* 左マージンを広くする */
               margin-right: 60px; /* 右マージンを広くする */
           }
        </style>
    <style>
        .two-columns {
            display: flex;
            flex-direction: row;
            gap: 20px; /* 列間のスペース */
        }
        .column {
            flex: 1; /* 各列が均等に幅を取る */
        }
    </style>
<style>
.three-columns {
  display: flex;
  gap: 10px; /* 列間の余白を設定 */
}
.column {
  flex: 1; /* 各列の幅を均等にする */
  padding: 10px; /* 内側の余白を設定 */
}
</style>
    <style>
        .styleRef { 
            text-indent: -40px; /* 最初の行の字下げを逆方向に */
            margin-left: 10px; /* 2行目以降の字下げを調整 */
            ul {
                  list-style-type: none; /* 箇条書き記号を非表示 */
                  padding-left: 40px; /* 全体の左余白 */
            }
            li {
            }
        }
    </style>
    <style>
        .styleBullet { 
            text-indent: -20px; /* 最初の行の字下げを逆方向に */
            margin-left: 30px; /* 2行目以降の字下げを調整 */
            ul {
                  list-style-type: none; /* 箇条書き記号を非表示 */
                  padding-left: 0px; /* 全体の左余白 */
            }
            li {
            }
        }
    </style>
    <style>
            ol
            {
                margin-left: 30px;
            }
            ul
            {
                margin-left: 30px;
            }
    </style>
    </head>
    <body>
        <h1><center>５章 エッジ検出</center></h1>
<p>
ビジョン処理の初期の段階で場面内のオブジェクトの構造と特性の推定に関係のある画像内の特徴を識別する。エッジはその様な特徴の一つである。エッジは画像内の局所的な大変化であり、画像を解析するために重要な特徴である。エッジは一般に画像内の異なる2つの領域の境界に現れる。エッジ検出は画像から情報を復元する第一ステップである事が多い。重要性のためエッジ検出は活発な研究領域であり続けている。本章ではエッジの検出と定位のみを扱う。エッジ検出の基本概念を述べる。エッジ検出の基本問題を説明するために幾つかの一般的なエッジ検出器を使う。エッジを組み合わせて輪郭にするアルゴリズムは6章で述べる。
</p>
<p>
  画像内のエッジは画像輝度の局所的な大変化であり、通常画像輝度または画像輝度の一次導関数の不連続と関連付けられる。画像機度の不連続には(1)階段状不連続－不連続の一方の側の値から反対側の値へ画像輝度が飛躍的に変化する－と(2)線不連続－画像輝度は飛躍的に変化するが短い距離をおいて元の値に戻る－がある。しかし階段エッジも線エッジも実際の画像では滅多に無い。たいていのセンシング・デバイスがもたらす低周波成分や平滑化のために、鋭い不連続は実際の画像では滅多に無いのである。階段状エッジは傾斜(ramp)エッジに、線エッジはルーフエッジになり輝度の変化は瞬間的ではなく有限の距離で中で起こる。これらのエッジの特性(profile)の図説を図5.1に示す。
</p>
<center><img src="images/fig5_1.png"></center>
<p>
<center>図5.1 一次元エッジ特性</center>
</p>
<p>
  1つのエッジが階段特性と線特性の両方を持つ事も可能である。例えば1つの平らな面から別の面に向きが変わる表面は階段エッジを作るであろう；しかし表面が鏡面反射成分を持ち表面の角が丸まっているなら、鏡面反射成分のため丸まった角の表面の向きが鏡面反射を起こす角度を通る時にハイライトが出来るであろう。この様な状況で生じるエッジ特性は階段エッジに線エッジが重なった様に見える。画像輝度の一次導関数の変換と関連付けられるエッジもある。例えば窪んだ角の側面からの相互反射はルーフエッジを作る。エッジは場面内のオブジェクトの重要な特徴と対応している可能性があるので大切な画像特徴である。例えばオブジェクトの画像輝度と背景の画像輝度とは異なるのでオブジェクトの境界は通常階段エッジを作る。
</p>
<p>
  本章ではほとんど全面的に階段エッジを扱うが、ほとんどのアイディアは画像機度変化のその他のタイプにも適用出来る。理想的な階段エッジの断面と階段エッジの例を提供する実際の画像の断面を図5.2に示す。定義より画像輝度の局所的な大変化である。プロットは変化が大きくかつ局所的なのでエッジである輝度変化を示している。またプロットは定義の一部を違反しているためエッジとは言えない変化も示している。ノイズによる変化は変化が局所的であってもエッジではない。なぜなら変化は大きくないからである。プロットの右側のランプの様な陰影による変化はたとえ変化が大きくてもエッジではない。なぜなら変化は局所的ではない。現実の画像は非常にノイズが多い。安定して階段エッジを探し出しノイズに強いエッジ検出演算子を開発する事は難しい。
</p>
<center><img src="images/fig5_2.png"></center>
<p>
図5.2　(a) 連結ロッド画像の上半分。(b) 理想的な画像強度のステップ変化のプロファイルをプロットしたもの。エッジが完全にシャープではなく、ノイズによって画像が乱れていることを示している。このプロットは、連結ロッドの円形部分を水平に切断したもので、上に示した部分的なロッド画像の下端に対応している。
</p>
<p>
エッジ検出演算子の重要な考察をする前にいくつかの用語を注意深く定義しておかなければならない。
<div class="styleBullet">
<ul>
<li><strong>定義5.1</strong>  エッジ点は座標 \([i, j]\) の画像内の点であり、その場所で輝度の局所的な大変化がある。</li><br>
<li><strong>定義5.2</strong>  エッジ断片はエッジの \(i, j\) それと勾配角の可能性のあるエッジ方向 \(θ\) に対応している。</li><br>

<li><strong>定義5.3</strong>  エッジ検出器は画像からエッジの集合(エッジ点やエッジ断片)を作るアルゴリズムである。</li><br>

<li><strong>定義5.4</strong>  輪郭はエッジのリストかまたはエッジリストをモデル化する数学的曲線である。</li><br>

<li><strong>定義5.5</strong>  エッジ連結処理(edge linking)は順序付けされていないリストから順序付けされたエッジリストを形成する工程である。慣例によりエッジは時計周りに順序付けされる。</li><br>

<li><strong>定義5.6</strong>  エッジ追跡(edge following)は輪郭を判断するために(フィルタを掛けられた)画像を調べる事である。</li><br>

</ul>
</div>
</p>
<p>
  エッジ点の座標はエッジが検出された整数値の行、列インデックスかも知れないし、サブピクセル解像度のエッジ位置座標かもしれない。エッジ座標は元の画像の座標系の事もあるが、フィルタ処理が画像座標を平行移動したり拡大・縮小したりするかも知れないのでエッジ検出フィルタが生成する画像の座標系の方が多いようである。エッジ断片はピクセルサイズの短い線分あるいは方向属性を持った点として概念化できる。エッジと言う用語は一般にエッジ点とエッジ断片のどちらにも使われる。
</p>
<p>
  エッジ検出器によって生成されるエッジ集合は2つの部分集合に分けられる。場面内のエッジと対応する正しいエッジと、場面内のエッジとは対応しない誤ったエッジである。エッジの第三の集合は場面内のエッジで検出されるべきものとして定義される。これは失われたエッジの集合である。誤ったエッジは正の偽エッジと呼ばれ、失われたエッジは負の偽エッジと呼ばれる。
</p>
<p>
  エッジ連結処理とエッジ追跡の違いは、エッジ連結処理はエッジ検出器の生成した順序付けされていないエッジの集合を入力として受け取って順序付けされたエッジのリストを形成する事にある。エッジ追跡は画像を入力として受け取り順序付けされたエッジリストを生成する。エッジ検出はピクセルがエッジか否かを決めるために局所的情報を使うのに対してエッジ追跡は大域情報を使う事が出来る。
</p>
<h2>5.1  勾配(Gradient)</h2>
<p>
エッジ検出は基本的には画像内で局所的な大きな変化を検出する操作である。1次元の場合、階段エッジは一階の導関数の局所的なピークと関連付けられる。勾配は関数の変化の計量であり、画像とは画像輝度のある連続関数のサンプルの配列であると考える事が出来る。アナロジーにより画像内のグレイ値の大きな変化は勾配の離散近似を使う事で検出出来る。勾配は一階導関数の2次元の等化物であり、ベクトルとして定義される。
\[
G[f(x,y)]=\Bigg[
\begin{array}{c}
G_x \\
G_y
\end{array}
\Bigg] =\Bigg[
\begin{array}{c}
\frac{\partial f}{\partial x} \\
\frac{\partial f}{\partial y}
\end{array}
\Bigg] \tag{5.1}
\]
勾配に関しては2つの重要な特性がある。(1)ベクトル \(G[f(x,y)]\) は関数の増加が最大になる方向を指す。(2)次式で与えられる勾配の大きさは
\[
G[f(x,y)]=\sqrt{G_x^2+G_y^2} \tag{5.2}
\]
\(G\) の方向に単位距離移動した場合の \(f(x､y)\) の最大増加率に等しい。しかし実際には勾配の大きさは絶対値で近似する事が一般的である。
\[
G[f(x,y)]\approx |G_x|+|G_y| \tag{5.3}
\]
または
\[
G[f(x,y)]\approx \max(|G_x|,|G_y|) \tag{5.4}
\]
ベクトル解析から勾配の方向は次式で定義される。
\[
\alpha(x,y)=\tan^{-1}\left(\frac{G_y}{G_x}\right) \tag{5.5}
\]
ここで角度 \(α\) は \(x\) 軸を基準に測る。
</p>
<p>
  勾配の大きさはエッジの方向とには依存していない事に注意して欲しい。この様な演算子は等方演算子(isotropic operator)と呼ばれる。
</p>
<p>
<strong>数値近似</strong><br>
ディジタル画像では式5.1の導関数は差分で近似される。最も単純な勾配の近似は以下の様になる。
\[
\begin{align}
G_x &\simeq f[i,j+1]-f[i,j] \tag{5.6} \\
\\
G_y &\simeq f[i,j]-f[i+1,j] \tag{5.7}
\end{align}
\]
\(j\) が \(x\) 方向、\(i\) が負の \(y\) 方向だった事を思い出そう。これらは以下の簡単な畳み込みマスクで実現出来る。
\[
G_x=
\begin{array}{|c|c|}
\hline
-1 & ~1~ \\
\hline
\end{array}
　　G_y=
\begin{array}{|c|}
\hline
~1~ \\
\hline
-1\\
\hline
\end{array}
\tag{5.8}
\]
</p>
<p>
   勾配の近似を計算する際に、空間内の正確に同じ位置で \(x\) と \(y\) の偏導関数を計算する事が極めて重要である。しかし上の近似を使うと勾配は実際には \(G_x\) では補間点 \([i, j+\frac{1}{2}]\) で計算され、\(G_y\) は \([i+\frac{1}{2}, j]\) で計算される。このため \(2×1\) マスクや \(1×2\) マスクではなく、\(2×2\) の一階差分が \(x,y\) の偏導関数として使われる事が多い。
\[
G_x=
\begin{array}{|c|c|}
\hline
-1 & ~1~\\
\hline
-1 & ~1~ \\
\hline
\end{array}
　　G_y=
\begin{array}{|c|c|}
\hline
~1~ & ~1~\\
\hline
-1 & -1 \\
\hline
\end{array}
\tag{5.9}
\]
これで \(x,y\) 方向で勾配が計算される位置が同じになった。その点は \(2×2\) 近傍の4ピクセル全ての間の補間点 \([i+\frac{1}{2}, j+\frac{1}{2}]\) にある。この事実は混乱となる事がある。そこで別の手法では3×3近傍を使い、勾配は中心点に関して計算する。この方法は5.2節で述べる。
</p>
<h2>5.2  エッジ検出のステップ</h2>
<p>
エッジ検出アルゴリズムは3ステップから成る。
<div class="styleBullet">
<ul>
<li><strong>フィルタ処理</strong>　2点のみの輝度値に基づいた勾配算出はノイズやその他の離散計算の予測のつかない変動(? vagaries:気まぐれ)の影響を受けやすいので、ノイズに対するエッジ検出の性能を改善するために一般的にフィルタ処理が使われる。しかしエッジ強度とノイズ削減の間にはトレードオフがある。フィルタ処理を多くするとノイズは減るがエッジ強度が失われる。</li><br>

<li><strong>強調処理</strong>　エッジ検出を容易にするため点の近傍での輝度の変化を判定する事が基本である。強調処理は局所的な輝度値が大きく変化しているピクセルを強調する。これは通常、勾配の大きさを計算する事で実行される。</li><br>

<li><strong>検出</strong>　我々は強いエッジ成分を持つ点だけが欲しい。しかし画像内の多くの点は非0の勾配を持ち、個々の応用ではそれらの点全てがエッジと言う訳ではない。従ってどの点がエッジであるかを判定する何らかの方法を使わなければならない。しきい処理が検出で使われる基準を提供する事が多い。</li>
</ul>
</div>
</p>
<p>
本節の終わりにある例は様々なエッジ検出器を使ってこれらのステップのそれぞれを明快に説明している。多くのエッジ検出アルゴリズムは第四ステップを含んでいる。
<div class="styleBullet">
<ul>
<li><strong>定位</strong>　応用で必要とされるならサブピクセル解像度でエッジ位置が推定出来る。エッジの方向も推定出来る。</li>
</ul>
</div>
</p>
<p>
  検出は単に画像内のあるピクセルの近くにエッジが存在する事を示すだけで、エッジの位置や方向の正確な推定は必ずしも提供しない事に注意する事が重要である。エッジ検出の誤りは分類ミスと言う誤りになる：偽エッジとエッジエッジ消失推定の誤りは位置と方向の推定の確率分布でモデル化される。エッジ検出とエッジ推定は異なる計算を実行し、異なる誤りモデルを持つので区別する。
</p>
<p>
  多くのエッジ検出器がこの20年の間に開発されてきた。ここで一般的に使われるエッジ検出器の幾つかを述べる。明らかになる様に、エッジ検出器は上の3ステップの内の1つかそれ以上コンピュータ処理手法の使う方が異なっている。エッジ検出器を述べた後でこれらのステップの関係について述べる事にする。
</p>
<h3>5.2.1  Roberts演算子</h3>
<p>
Roberts交差演算子は勾配の大きさの簡単な近似を与える。
\[
G[f[i,j]]=|f[i,j]-f[i+1,j+1]+f[i+1,j]-f[i,j+1]| \tag{5.10}
\]
畳み込みマスクを使うと以下の様になる。
\[
G[f[i,j]]=|G_x|+|G_y| \tag{5.11}
\]
ここで \(G_x\) と \(G_y\) は以下のマスクを使って計算される。
\[
G_x=
\begin{array}{|c|c|}
\hline
~~1~~ & ~~0~~ \\
\hline
0 & -1 \\
\hline
\end{array}
　　G_y=
\begin{array}{|c|c|}
\hline
~~0~~ & -1\\
\hline
1 & ~~0~~ \\
\hline
\end{array}
\tag{5.12}
\]
前の \(2×2\) 勾配演算子と同様に差分は補間点 \([i+\frac{1}{2}, j+\frac{1}{2}]\) で計算される。Roberts演算子はこの点で連続勾配を近似しており、期待される \([i, j]\) ではない。Robertsエッジ検出器の結果を本節末の図に示す。
</p>
<h3>5.2.2  Sobel演算子</h3>
<p>
前に述べた様にピクセルの間の補間点で勾配を計算する事を避ける方法は、勾配計算に3×3近傍を使う事である。図5.3に示す様にピクセル[i, j]の周りにピクセルが配置されているとしよう。
</p>
<p>
\[
\begin{array}{|c|c|c|}
\hline
~~a_0~~ & a_1 & ~~a_2~~ \\
\hline
a_7 & [i,j] & a_3 \\
\hline
a_6 & a_5 & a_4 \\
\hline
\end{array}
\]
<center>図5.3  Sobel演算子とPrewitt演算子の説明で使う近傍ピクセルのラベル付け</center>
</p>
<p>
Sobel演算子は次式で勾配の大きさを計算する。
\[
M=\sqrt{s_x^2+s_y^2} \tag{5.13}
\]
ここで偏導関数は次の様に計算する。
\[
\begin{align}
s_x=(a_2+ca_3+a_4)-(a_0+ca_7+a_6) \tag{5.14} \\
\\
s_y=(a_0+ca_1+a_2)-(a_6+ca_5+a_4) \tag{5.15}
\end{align}
\]
定数 \(c＝2\) を使う。
</p>
<p>
　他の勾配演算子と同様に \(s_x\) と \(s_y\) は畳み込みマスクを使って実現出来る。
\[
s_x=
\begin{array}{|c|c|c|}
\hline
-1 & ~0~ & ~1~ \\
\hline
-2 & ~0~ & ~2~ \\
\hline
-1 & ~0~ & ~1~ \\
\hline
\end{array}
　　
s_y=
\begin{array}{|c|c|c|}
\hline
1 & 2 & 1 \\
\hline
0 & 0 & 0 \\
\hline
-1 & -2 & -1 \\
\hline
\end{array}
\tag{5.16}
\]
この演算子はマスクの中心に近いピクセルを強調している事に注意して欲しい。本節末の図はこの演算子の性能を示している。Sobel演算子は最も一般的に使われているエッジ検出器の一つである。
</p>
<h3>5.2.3  Prewitt演算子</h3>
<p>
Prewitt演算子は定数 \(c＝1\)とする以外はSobel演算子と同じ式を使う。従って
\[
s_x=
\begin{array}{|c|c|c|}
\hline
-1 & ~0~ & ~1~ \\
\hline
-1 & ~0~ & ~1~ \\
\hline
-1 & ~0~ & ~1~ \\
\hline
\end{array}
　　
s_y=
\begin{array}{|c|c|c|}
\hline
1 & 1 & 1 \\
\hline
0 & 0 & 0 \\
\hline
-1 & -1 & -1 \\
\hline
\end{array}
\tag{5.17}
\]
Sobel演算子とは違ってこの演算子はマスクの中心に近いピクセルを強調していない。このエッジ検出器の性能も本節末の図に示す。
</p>
<h3>5.2.4  比較</h3>
<p>
これまでに述べた各種エッジ検出器を比較する。比較は本節の最初に説明した最初の3ステップに従って提示される：フィルタ処理、強調、検出。推定ステップについてはここでは示さない。更にノイズのある画像にエッジ検出した結果を2つの特別な場合で提示する－一つはフィルタ処理ステップを使った場合で、一つはフィルタ処理ステップを省略した場合である。様々な量のフィルタ処理を使ったエッジ検出結果も提示する。
</p>
<p>
　以下の4つの図のそれぞれに対して、勾配の \(x\) 成分、\(y\) 成分の絶対値の和が勾配の大きさとして使われた(式5.3)。使われたフィルタは前章で説明した \(7×7\) ガウシアン・フィルタである。検出に使われた閾値はキャプションで与える。
</p>
<p>
　図5.4は、単純な \(1×2\) 勾配近似から、Prewitt演算子までの、これまでに説明したすべてのエッジ検出法の結果を示す。図5.5フィルタ処理ステップを省略した場合の結果を示す。その後の画像の組(図5.6)は、同じ画像に追加でガウシアン・ノイズ \(σ=12\) を使った場合のエッジ検出結果を示す。使われるフィルタは前の図で使われたものと同じガウシアン・フィルタである。一連の図の最後(図5.7)は同じノイズのある画像に対してエッジ検出を行った結果である。しかし、これらの画像は再び、フィルタ処理ステップが省略されている。ノイズの結果、多くの偽エッジが検出されていることに注目してもらいたい。
</p>
<center><img src="images/fig5_4.png"></center>
<p>
図5.4　各種エッジ検出の比較。(a)オリジナル画像。(b)フィルタされた画像。(c)\(1×2,2×1\)マスク、\(T=32\) を使った単純勾配。(d) \(2×2\) マスク、\(T=64\) を使った勾配。(e)Robertsクロス演算子、\(T=64\)。(f)Sobel演算子、\(T=225\)。(g)Prewitt演算子、\(T=225\)
</p>
<center><img src="images/fig5_5.png"></center>
<p>
図5.5　フィルタ処理無しでの各種エッジ検出の比較。(a)オリジナル画像。(b) \(1×2,2×1\) マスク、\(T=64\) を使った単純勾配。(c) \(2×2\) マスク、\(T=64\) を使った勾配。(d)Robertsクロス演算子、\(T=64\)。(e)Sobel演算子、\(T=225\)。(f)Prewitt演算子、\(T=225\)
</p>
<center><img src="images/fig5_6.png"></center>
<p>
図5.6　ノイズのある画像に対する各種エッジ検出の比較。(a)ノイズのある画像。(b)フィルタされた画像。(c) \(1×2,2×1\) マスク、\(T=32\) を使った単純勾配。(d) \(2×2\) マスク、\(T=64\) を使った勾配。(e)Robertsクロス演算子、\(T=64\)。(f)Sobel演算子、\(T=225\)。(g)Prewitt演算子、\(T=225\)
</p>
<center><img src="images/fig5_7.png"></center>
<p>
図5.7　フィルタ処理無しでノイズのある画像に対する各種エッジ検出の比較。(a)ノイズのある画像。(b) \(1×2,2×1\) マスク、\(T=64\) を使った単純勾配。(c) \(2×2\) マスク、\(T=128\) を使った勾配。(d)Robertsクロス演算子、\(T=64\)。(e)Sobel演算子、\(T=225\)。(f)Prewitt演算子、\(T=225\)
</p>
<h2>5.3　二次導関数演算子(Second Derivative Operators)</h2>
<p>
前に議論したエッジ検出器は一次導関数を計算し、もしもそれが閾値より大きい場合はエッジ点があると仮定された。その結果はエッジ点を多く検出し過ぎた (図5.4から図5.7の閾値処理後の太い線に注目して貰いたい)。もっと良い手法は、図5.8に示す様に、傾斜の極大値を取る点のみを探し、それらをエッジ点と見なすというものである。これは、エッジ点では一次導関数がピークになる、つまり二次導関数が0交差することを意味している。従って、エッジ点は画像輝度の二次導関数の0交差を探すことで検出できる。
</p>
<p>
　二次導関数に対応する二次元の演算子は2つある：ラプラシアン(Laplacian)と二次方向導関数である。
</p>
<h3>5.3.1 ラプラス演算子(Laplacian Operator)</h3>
<p>
平滑化されたステップ・エッジの二次導関数はエッジの位置で0と交差する関数になる(図5.8参照)。
</p>
<center><img src="images/fig5_8.png"></center>
<p>
図5.8　エッジの検出に閾値が使われる場合、\(a\) と \(b\) の間のすべての点がエッジ・ピクセルと識別される。しかし、一次導関数の極大ではない点を除去することでエッジをより正確に検出することができる。この一次導関数の極大は二次導関数の0交差に対応する
</p>
<p>
ラプラシアンは二次導関数の二次元等価物である。関数 \(f(x,y)\) のラプラシアンの式は以下で表される。
\[
\nabla^2 f=\frac{\partial^2 f}{\partial x^2}+\frac{\partial^2 f}{\partial y^2} \tag{5.18}
\]
\(x\) 方向と \(y\) 方向に沿った二次導関数は差分方程式を使って近似される。
\[
\begin{align}
\frac{\partial^2 f}{\partial x^2} &= \frac{\partial G_x}{\partial x} \tag{5.19} \\
\\
&= \frac{\partial(f[i,j+1]-f[i,j])}{\partial x} \tag{5.20} \\
\\
&= \frac{\partial f[i,j+1]}{\partial x}-\frac{\partial f[i,j]}{\partial x} \tag{5.21} \\
\\
&=(f[i,j+2]-f[i,j+1]) -(f[i,j+1]-f[i,j]) \tag{5.22} \\
\\
&=f[i,j+2]-2f[i,j+1]+f[i,j] \tag{5.23}
\end{align}
\]
しかし、この近似はピクセル \([i,j+1]\) を中心としている。従って \(j\) を \(j-1\) で置換することにより以下の式を得る。
\[
\frac{\partial^2 f}{\partial x^2}=f[i,j+1]-2f[i,j]+f[i,j-1] \tag{5.24}
\]
これは \([i,j]\) を中心とした二次偏導関数の希望する近似である。同様に、
\[
\frac{\partial^2 f}{\partial y^2}=f[i+1,j]-2f[i,j]+f[i-1,j] \tag{5.25}
\]
これら二式を一つの演算子にまとめると、以下のマスクがラプラシアンの近似として使える。
\[
\nabla^2\approx
\begin{array}{|c|c|c|}
\hline
~~0~~ & ~~1~~ & ~~0~~ \\
\hline
~~1~~ & -4 & ~~1~~ \\
\hline
~~0~~ & ~~1~~ & ~~0~~ \\
\hline
\end{array}
\tag{5.26}
\]
近傍内の中心ピクセルにもっと重みを与えることが望まれる場合が時々ある。その様なラプラシアン近似は以下になる。
\[
\nabla^2\approx
\begin{array}{|c|c|c|}
\hline
~~~1~~~ & ~~~4~~~ & ~~~1~~~ \\
\hline
~~~4~~~ & -20 & ~~~4~~~ \\
\hline
~~~1~~~ & ~~~4~~~ & ~~~1~~~ \\
\hline
\end{array}
\tag{5.27}
\]
ラプラス演算子は、演算子の出力が0を通過する場合、エッジの存在を伝える。自明な0(一様に0の領域)は無視される。原理上、0交差位置は線形補間を使ってサブピクセル解像度で推定することができるが、結果はノイズのため不正確になるかもしれない。
</p>
<p>
　図5.9に示す例を考えよう。この図は単純なステップ・エッジを持つ画像でのラプラシアンの結果を示している。
</p>
<p>
\[
\begin{array}{|c|c|c|c|c|c|c|c|c|c|}
\hline 
2 & 2 & 2 & 2 & 2 & 8 & 8 & 8 & 8 & 8 \\ 
\hline 
2 & 2 & 2 & 2 & 2 & 8 & 8 & 8 & 8 & 8 \\ 
\hline 
2 & 2 & 2 & 2 & 2 & 8 & 8 & 8 & 8 & 8 \\ 
\hline 
2 & 2 & 2 & 2 & 2 & 8 & 8 & 8 & 8 & 8 \\ 
\hline 
2 & 2 & 2 & 2 & 2 & 8 & 8 & 8 & 8 & 8 \\ 
\hline 
2 & 2 & 2 & 2 & 2 & 8 & 8 & 8 & 8 & 8 \\ 
\hline
\end{array}
\]
<center>垂直のステップ・エッジを含む単純な画像</center>
\[
\begin{array}{|c|c|c|c|c|c|c|c|}
\hline 
~0~ & ~0~ & ~0~ & ~6~ & -6 & ~0~ & ~0~ & ~0~ \\ 
\hline 
~0~ & ~0~ & ~0~ & ~6~ & -6 & ~0~ & ~0~ & ~0~ \\ 
\hline 
~0~ & ~0~ & ~0~ & ~6~ & -6 & ~0~ & ~0~ & ~0~ \\ 
\hline 
~0~ & ~0~ & ~0~ & ~6~ & -6 & ~0~ & ~0~ & ~0~ \\ 
\hline 
\end{array}
\]
<center>図5.9　垂直ステップ・エッジに対するラプラシアンの応答</center>
</p>
<p>
結果の画像の１行は以下の通り：
\[
\begin{array}{|c|c|c|c|c|c|c|c|}
\hline 
~0~ & ~0~ & ~0~ & ~6~ & -6 & ~0~ & ~0~ & ~0~ \\ 
\hline 
\end{array}
\]
この例で、オリジナル画像のエッジに対応している0交差は、2つの中央ピクセルの中間にある。画像全体で一貫している限り、エッジの左のピクセルに記をつけても良いし、エッジの右のピクセルに記をつけても良い。とは言え、たいていの場合0交差が2つのピクセルのちょうど真ん中にあることは稀であり、実際のエッジの位置は0交差の両側のピクセル値を補間して決めなければならない。
</p>
<p>
　今度は図5.10の例を考えよう。この図はランプ(傾斜)エッジに対するラプラシアンの応答を示している。
\[
\begin{array}{|c|c|c|c|c|c|c|c|c|c|}
\hline 
2 & 2 & 2 & 2 & 5 & 8 & 8 & 8 & 8 & 8 \\ 
\hline 
2 & 2 & 2 & 2 & 5 & 8 & 8 & 8 & 8 & 8 \\ 
\hline 
2 & 2 & 2 & 2 & 5 & 8 & 8 & 8 & 8 & 8 \\ 
\hline 
2 & 2 & 2 & 2 & 5 & 8 & 8 & 8 & 8 & 8 \\ 
\hline 
2 & 2 & 2 & 2 & 5 & 8 & 8 & 8 & 8 & 8 \\ 
\hline 
2 & 2 & 2 & 2 & 5 & 8 & 8 & 8 & 8 & 8 \\ 
\hline
\end{array}
\]
<center>垂直の傾斜エッジを含む単純な画像</center>
\[
\begin{array}{|c|c|c|c|c|c|c|c|}
\hline 
~0~ & ~0~ & ~0~ & ~3~ & ~0~ & -3 & ~0~ & ~0~ \\ 
\hline 
~0~ & ~0~ & ~0~ & ~3~ & ~0~ & -3 & ~0~ & ~0~ \\ 
\hline 
~0~ & ~0~ & ~0~ & ~3~ & ~0~ & -3 & ~0~ & ~0~ \\ 
\hline 
~0~ & ~0~ & ~0~ & ~3~ & ~0~ & -3 & ~0~ & ~0~ \\ 
\hline 
\end{array}
\]
<center>図5.10　垂直ランプ・エッジに対するラプラシアンの応答</center>
</p>
<p>
ラプラシアンの出力の1行は以下の通りである。
\[
\begin{array}{|c|c|c|c|c|c|c|c|}
\hline 
~0~ & ~0~ & ~0~ & ~3~ & ~0~ & -3 & ~0~ & ~0~ \\ 
\hline 
\end{array}
\]
0交差は画像内のピクセルに直接対応している。繰り返すが、これは理想的な状況であり、本当のエッジ位置は補間により決めなければならない。
</p>
<h3>5.3.2　二次方向導関数(Second Directional Derivative)</h3>
<p>
二次方向導関数は、傾斜をある方向で計算した二次導関数である。演算子は以下の式を使って実装される。
\[
\frac{\partial^2}{\partial n^2}=\frac{f_x^2f_{xx}+2f_xf_yf_{xy}+f_y^2f_{yy}}{f_x^2+f_y^2} \tag{5.28}
\]
</p>
<p>
　二次導関数を伴うどんな演算子も、一次導関数を伴う演算子よりもノイズの影響を受けるため、ラプラス演算子も二次方向導関数演算子も、マシン・ビジョンではあまり頻繁には使われない。一次導関数の非常に小さな極大であっても、二次導関数で0交差を生じる。ノイズの影響を避けるためには、強力なフィルタ処理法を使わなければならない。次の節では、エッジ検出にガウス・フィルタ処理と二次導関数を組み合わせる手法について議論する。
</p>
<h2>5.4　ガウシアンのラプラシアン(Laplacian of Gaussian)</h2>
<p>
前述の様に、画像強度の二次導関数の0交差を見つけることで検出されたエッジ点は、非常にノイズに敏感である。このため、エッジ強調前にノイズ除去することが望まれる。これを行うために、MarrとHildreth[文献164]によるガウシアンのラプラシアン(LoG：Laplacian of Gaussian)は、エッジ検出のためにガウス・フィルタ処理とラプラシアンを組み合わせている。LoGエッジ検出の基本的な特徴は以下の様になる
<div class="styleBullet">
<ul>
<li>1.　平滑フィルタはガウシアンである</li>
<li>2.　強調ステップは二次導関数である(2次元のラプラシアン)</li>
<li>3.　検出基準は一次導関数の大きなピークに対応する二次導関数の0交差である</li>
<li>4.　エッジ位置は線形補間を使ってサブピクセル解像度で推定できる</li>
</ul>
</div>
</p>
<p>
　この手法では、画像はガウシアン・フィルタで畳み込みされる(5.6節でガウシアン・フィルタ処理についてより詳しく説明する)。このステップで平滑化を行いノイズを削減する。孤立ノイズ点と小さな構造は取り除かれる。平滑化はエッジを広げるので、エッジ検出器は勾配が極大値をとるピクセルのみがエッジであるとみなす。これは二次導関数の0交差を使うことで実現される。ラプラシアンは等方演算子なので、2Dの二次導関数の近似として使われる。取るに足りないエッジの検出を避けるため、対応する一次導関数がある閾値より大きい0交差のみがエッジ点として選択される。
</p>
<p>
　LoG演算子の出力、h(x,y)は演算子を畳み込みすることで得られる。
\[
h(x,y)=\nabla^2[g(x,y)*f(x,y)] \tag{5.29}
\]
畳み込みに微分ルールを使うことで以下が得られる。
\[
h(x,y)=\left[\nabla^2g(x,y)\right] *f(x,y) \tag{5.30}
\]
ここで
\[
\nabla^2g(x,y)=\left(\frac{x^2+y^2-2\sigma^2}{\sigma^4}\right)e^{-\frac{(x^2+y^2)}{2\sigma^2}} \tag{5.31}
\]
は一般にメキシカン・ハット演算子(図5.11に示す)と呼ばれる
</p>
<center><img src="images/fig5_11.png"></center>
<p>
<center>図5.11　反転した一次元および二次元のガウシアンのラプラシアン関数。\(σ＝2\)</center>
</p>
<p>
従って以下の2つの方法は数学的には等価である。
<div class="styleBullet">
<ul>
<li>1.　画像とガウシアン平滑フィルタを畳み込みし、結果のラプラシアンを計算する</li>
<li>2.　画像と線形フィルタであるLoGを畳み込みする</li>
</ul>
</div>
</p>
<p>
最初の方法を採用した場合、4.5.5節で説明した様なガウシアン平滑マスクが使われる。直接LoGを実現する典型的なマスクを図5.12に与える。
\[
\begin{array}{|c|c|c|c|c|}
\hline
~0~ & ~0~ & -1 & ~0~ & ~0~ \\
\hline
~0~ & -1 & -2 & -1 & ~0~ \\
\hline
-1 & -2 & 16 & -2 & -1 \\
\hline
~0~ & -1 & -2 & -1 & ~0~ \\
\hline
~0~ & ~0~ & -1 & ~0~ & ~0~ \\
\hline
\end{array}
\]
<center>5×5　ガウシアンのラプラシアン・マスク</center>
</p>
<center><img src="images/fig5_12.png"></center>
<p>
<center>17×17　ガウシアンのラプラシアン・マスク</center>
<center>図5.12　実用的ないくつのガウシアンのラプラシアン・マスク[文献146]</center>
</p>
<p>
図5.13で、LoG演算子を適用し0交差を検出した結果を図5.13に示す。LoG実装の効率的な方法については文献[117]参照。
</p>
<center><img src="images/fig5_13.png"></center>
<p>
<center>図5.13　ガウシアンのラプラシアン・エッジ検出器の結果</center>
</p>
<p>
　1.2節の始めでフィルタ処理(通常平滑化処理)、強調、検出がエッジ検出の3ステップであると述べた。これはLoGを使ったエッジ検出でも当てはまる。平滑化はガウシアン・フィルタで実行され、エッジを0交差に変換することで強調が行われ、0交差を検出することで検出が行われる。
</p>
<p>
　0交差の傾きはエッジに沿った画像輝度の変化のコントラストに依存することを示すことができる。異なるサイズの演算子を画像に適用することで得られたエッジを組み合わせる問題が残っている。上の手法では、特定の解像度におけるエッジが得られる。画像内の本当のエッジを得るためには、いくつかのフィルタ・サイズでの演算子からの情報を組み合わせる必要があるかもしれない。
</p>
<p>
<strong>スケール空間(Scale Space)</strong><br>
ガウシアン平滑演算子は画像内のエッジやその他の鋭い不連続性にぼけを生じる。ぼけの量はσの値に依存する。σが大きいほどノイズ除去は良好になるが、同時に重要なエッジ情報を失い、エッジ検出器の性能に影響する。小さいフィルタを使った場合、不十分な平均化のためノイズが多く残りそうである。大きいフィルタでは、お互いに近いエッジが平滑化により結合され、一つのエッジとして検出されるかも知れない。一般に小さいフィルタでは多くのノイズ点を生じ、大きなフィルタではエッジの転移や、誤ったエッジさえ生じる。フィルタの正確なサイズは画像内のオブジェクトのサイズや位置がわからないと決めることができない。
</p>
<p>
　複数のサイズのフィルタ処理マスクを適用し、その後でこれらの異なるスケールのフィルタ処理でエッジの挙動を解析する多くの手法が開発されている。これらの手法の基本的なアイディアは、より高いスケールでは、より大きいフィルタ処理マスクが堅牢だが転移したエッジを生じるという事実を利用するというものである。これらのエッジの位置は、より小さいスケールで決めることができる。
</p>
<h2>5.5　画像近似(Image Approximation)</h2>
<p>
画像は連続関数のサンプルの配列である。画像に関するたいていのアイディアは連続領域で議論され、その後で望まれる特性が離散近似を使って計算される。画像サンプルの取得元である連続関数が推定できる場合、推定された関数から画像の特性を計算することができる。これによりエッジ位置をサブピクセル精度で計算することができる。
\[
z=f(x,y) \tag{5.32}
\]
が図5.14に示す様な連続画像輝度関数とする。
</p>
<center><img src="images/fig5_14.png"></center>
<p>
<center>図5.14　連続画像輝度関数のグラフィカルな表現</center>
</p>
<p>
課題はサンプルされたグレイ値からこの連続関数を再構成することである。複雑な画像では、連続画像輝度関数は極めて高次のxやyのべきを含む。これにより、オリジナル関数の再構成は不可能でなかったとしても極めて困難になる。そのため、画像を区分的に単純な解析関数でモデル化することを試みる。今度は、課題は個々の区分的関数または小平面(facet)の再構成になる。言い換えると、各ピクセルの局所的な近傍でのみ輝度値をもっともうまく近似する単純な関数を見つけようとすることである。これを図5.15で図説する。
</p>
<center><img src="images/fig5_15.png"></center>
<p>
<center>図5.15　5×5近傍内の近似関数の説明</center>
</p>
<p>
この近似はファセット・モデル(facet model)と呼ばれる[文献102]。図5.16は5×5近傍を使ったファセット・モデルに対する座標系を示している。
</p>
<p>
図5.16　\(5×5\) 近傍を使ったファセット・モデルの座標系の例。連続輝度関数は、各ピクセル位置のこの近傍内でのみで近似される。配列インデックスは明確化のためにピクセルに記されている。ピクセル \([i,j]\) が近傍の中心にあることに注意
</p>
<p>
　連続画像輝度関数が画像内の各ピクセルで局所的に近似される。\(n×m\) 画像では、\(n・m\) 個の近似関数が取得され、それぞれは画像内の特定のピクセルに関してのみ妥当である。ピクセル値ではなく、これらの関数は、画像内のエッジを見つけるために使われる。さまざまな複雑度の各種解析関数が画像輝度を近似するために使われる。多くの場合、単純な画像に対しては、区分定数または区分双線形関数が輝度値の近似に適している。とは言え、もっと複雑な領域を持つ画像では、双二次、双三次、またはもっと高次の関数が使われる。この例では、以下の双三次多項式で近傍画像をモデル化する。
\[
\begin{align}
f(x,y)=k_1+k_2x+k_3y+k_4x^2+k_5xy+k_6y^2 \\
+k_7x^3+k_8x^2y+k_9xy^2+k_{10}y^3 
\end{align}
\tag{5.33}
\]
ここで \(x,y\) は \((0,0)\) に対する座標であり、\((0,0)\) は近似される画像平面近傍の中心である(図5.16参照)。
</p>
<center><img src="images/fig5_16.png"></center>
<p>
図5.16　\(5×5\) 近傍を使ったファセット・モデルの座標系の例。連続輝度関数は、各ピクセル位置のこの近傍内でのみで近似される。配列インデックスは明確化のためにピクセルに記されている。ピクセル \([i,j]\) が近傍の中心にあることに注意
<p>
今度の目標は各近似関数に対して式5.33の係数 \(k_i\) を計算することである。特異値分解(singular-value decomposition)を使って係数 \(k_i\) を計算するために最小二乗法を使うか、\(5×5\) 近傍を使うのであれば、双三次近似の係数を直接計算するために図5.17に示したマスクを使う。
</p>
<center><img src="images/fig5_17.png"></center>
<p>
<center>図5.17　双三次近似の係数を計算するマスク</center>
</p>
<p>
　エッジを検出するため、エッジ点は、ピクセル近傍の画像輝度を近似する関数の一次方向導関数の相対的な極値に生じるという事実を使う。一次導関数に相対的極値があるということは、一次導関数の方向の二次導関数に0交差を生じる。
</p>
<p>
　方向 \(θ\) の一次導関数は以下で与えられる
\[
f_\theta^\prime(x,y)=\frac{\partial f}{\partial x}\cos\theta+\frac{\partial f}{\partial y}\sin\theta \tag{5.34}
\]
方向 \(θ\) の二次方向導関数は以下で与えられる
\[
f_\theta^{\prime\prime}(x,y)=\frac{\partial^2 f}{\partial x^2}\cos^2\theta+2\frac{\partial^2 f}{\partial x\partial y}\cos\theta\sin\theta+\frac{\partial^2 f}{\partial y^2}\sin^2\theta \tag{5.35}
\]
局所的な画像輝度は双三次多項式で近似されているので、角度 \(θ\) は近似面の角度になるように選ばれているかもしれない。その結果は以下の様になる。
\[
\begin{align}
\sin\theta &=\frac{k_3}{\sqrt{k_2^2+k_3^2}} \tag{5.36} \\
\\
\cos\theta &=\frac{k_2}{\sqrt{k_2^2+k_3^2}} \tag{5.37}
\end{align}
\]
点 \((x_0,y_0)\) における方向 \(θ\) の二次方向導関数は以下で与えられる。
\[
\begin{align}
f_\theta^{\prime\prime}(x_0,y_0)= &2(3k_7\cos^2\theta+2k_8\sin\theta\cos\theta+k_9\sin^2\theta)x_0 \\
\\
&+2(k_8\cos^2\theta+2k_9\sin\theta\cos\theta+3k_{10}\sin^2\theta)y_0 \\
\\
&+2(k_4\cos^2\theta+k_5\sin\theta\cos\theta+k_6\sin^2\theta) \tag{5.38}
\end{align}
\]
方向 \(θ\) の直線上の点のみを考えているので、\(x_0=ρcosθ,y_0=ρsinθ\)。上の式に代入して以下を得る。
\[
\begin{align}
f_\theta^{\prime\prime}(x_0,y_0) &=6(k_{10}\sin^3\theta+k_9\sin^2\cos\theta+k_8\sin\theta\cos^2\theta+k_7\cos^3\theta)\rho  \\
\\
&　+2(k_6\sin^2\theta+k_5\sin\theta\cos\theta+k_4\cos^2\theta) \tag{5.39} \\
\\
&=A\rho+B \tag{5.40}
\end{align}
\]
従って、ある \(ρ\) で \(|ρ|＜ρ_0\) となるなら、画像内の \((x_0,y_0)\) にエッジがある。ここで \(ρ_0\) はピクセルの側面の長さである。
\[
f_\theta^{\prime\prime}(x_0,y_0;\rho)=0 \tag{5.41}
\]
かつ
\[
f_\theta^\prime(x_0,y_0;\rho)\neq0 \tag{5.42}
\]
言い換えると、エッジの位置がピクセルの境界内に収まる、そのピクセルをエッジ・ピクセルとして印をつける(図5.18参照)。
</p>
<center><img src="images/fig5_18.png"></center>
<p>
図5.18　近似関数の中央ピクセルの拡大図。\((x_0, y_0)\) は式(5.41)、(5.42)によって決まるエッジの位置。エッジの位置が境界内に収まるので、そのピクセルはエッジ・ピクセルとして印が付けられる。
</p>
<p>
しかし、図5.19に示す様に、点がピクセル境界の外にあるなら、そのピクセルはエッジ・ピクセルとすて印は付けられない。この演算子の結果を図5.20に示す。
</p>
<center><img src="images/fig5_19.png"></center>
<p>
図5.19　近似関数の中央ピクセルの拡大図。エッジの位置がピクセル境界内に収まらないので、このピクセルはエッジ・ピクセルとして印は付けられない。
</p>
<center><img src="images/fig5_20.png"></center>
<p>
図5.20　ファセット・モデル・エッジ検出器を使って取得されたエッジ
</p>
<p>
<h2>5.6　ガウシアン・エッジ検出(Gaussian Edge Detection)</h2>
</p>
<p>
ステップ・エッジ検出における基本的な考え方は、サンプルされた画像内の勾配の大きさが局所的に大きい点を探すということである。ステップ・エッジ検出に関する研究活動の多くは、現実の画像に使うのに適している、勾配の数値近似を探すことに当てられている。カメラ・レンズの光学系に内在するローパス・フィルタや、カメラ電気系の帯域制限によりエッジが平滑化されるため、現実の画像のステップ・エッジには完全な鋭さはない。また画像はカメラからのノイズや場面の不要な細かさでひどく汚されている。画像勾配の近似は2つの相反する要求を満足しなければならない: (1)近似はノイズの影響を抑えなければならない、(2)近似は可能な限り正確にエッジの位置を突き止めなければならない。ノイズ抑圧と定位の間にはトレードオフがある。エッジ検出演算子は画像を平滑化することでノイズを削減することができるが、これはエッジの位置に不確実性を加える; または演算子はエッジの存在の感度を高くすることができるが、これは演算子のノイズ感度を増やす。ノイズ耐性と定位の間の最高の妥協点を提供し、ガウス・フィルタの利点を保持する線形演算子の型は、ガウシアンの一次導関数である。この演算子はガウス関数で画像を平滑化し、その後で勾配を計算することに対応する。勾配は5.1節に載せたx方向とy方向の偏導関数の標準有限差分近似を使って数値近似することができる。ガウス平滑フィルタと勾配近似を組み合わせた演算子は回転対称ではない。演算子はエッジに沿っては対称であるが、エッジの垂線に対しては反対称である。これは、この演算子が最も変化が急な方向のエッジには敏感であるが、エッジに対しては鈍感であり、エッジに沿った方向に対しては平滑演算子として振舞うことを意味している。
</p>
<h3>5.6.1　Cannyエッジ検出器</h3>
<p>
Cannyエッジ検出器はガウス分布の一次導関数であり、信号・ノイズ比と位置特定の積を最適化する演算子を綿密に近似する。Cannyエッジ検出アルゴリズムは以下の表記で要約できる。\(I[i ,j]\) が画像を表すとしよう。分離可能なフィルタ処理を使ってガウス平滑フィルタと画像を畳み込んだ結果は、平滑化されたデータの配列になる。
\[
S[i,j]=G[i,j;\sigma]*I[i,j] \tag{5.43}
\]
ここで \(σ\) はガウス分布の広がりで平滑化の度合いを制御する。
</p>
<p>
関数、\(y\) 偏導関数に対応する2つの配列 \(P[i, j]\) と \(Q[i, j]\) を生じる:
\[
\begin{align}
P[i,j]\approx(S[i,j+1]-S[i,j]+S[i+1,i+1]-S[i+1,j])/2 \tag{5.44} \\
\\
Q[i,j]\approx(S[i,j]-S[i+1,j]+S[i,j+1]-S[i+1,j+1])/2 \tag{5.45}
\end{align}
\]
\(x\) 偏導関数と \(y\) 偏導関数が画像上の同じ点で計算される様に、\(2×2\) の正方領域上で平均される。勾配の大きさと方向は直交座標・極座標変換用の標準公式から計算することができる。
\[
\begin{align}
M[i,j] &=\sqrt{P[i,j]^2+Q[i,j]^2} \tag{5.46} \\
\\
\theta[i,j] &=arctan(Q[i,j],P[i,j]) \tag{5.47}
\end{align}
\]
ここでarctan関数は2つの引数をとり、とり得る方向の全周上の角度を生成する。これらの関数は効率的に計算されなければならず、浮動小数算術を使わないことが望ましい。偏導関数から勾配の大きさと方向を計算するのにテーブル参照を使うことも可能である。逆正接(arctangent)は、整数と固定小数点算術を使って実行される不可欠な少数の浮動小数計算と、大部分は固定少数演算で計算することができる。Sedgewickは多くの応用で十分良好な勾配の角度を整数近似するアルゴリズムを提供している。
</p>
<p>
<strong>非極大抑圧(Non Maxima Suppression)</strong><br>
大きさの画像配列 \(M[i, j]\) は画像の勾配が大きいところで大きな値を持つが、それだけではエッジと識別するには十分ではない。なぜなら、画像配列内で急激に変化している箇所を探す問題が単に大きさの配列 \(M[i, j]\) 内の極大を探す問題に変換されただけだからである。エッジを特定するためには、大きさの局所的な変化が最大になる点がけが残るように、大きさの配列内で広がった尾根を細くしなければならない。この工程は非極大抑圧と呼ばれ、この場合、細線化されたエッジを生じる。
</p>
<p>
　非極大抑圧は、一連の勾配に沿って、尾根のピークではないすべての値を削除することにより勾配の大きさ \(M[i, j]\) 内の尾根を細線化する。そのアルゴリズムは勾配の角度 \(θ[i, j]\) を図5.21に示す4つの領域(sector)の1つに減らすことから始まる。
</p>
<center><img src="images/fig5_21.png"></center>
<p>
図5.21　非極大抑圧のためにとり得る勾配の方向をセクタに仕切ることが示されている。0から3の番号を付けられた4つのセクタがあり、3×3近傍の中心を通る直線がとり得る4つの組み合わせに対応している。勾配線の方向がとり得る円の分割は度数でラベル付けされている。
</p>
<p>
\[
\zeta[i,j]=Sector(\theta[i,j]) \tag{5.48}
\]
アルゴリズムは大きさの配列 \(M[i, j]\) の全域に \(3×3\) 近傍を渡す。各点で、近傍の中心におけるセクタ値 \(\zeta[i, j]\) で与えられる勾配の直線に沿った2つの近傍と、近傍の中心の \(M[i, j]\) 要素が比較される。中心における大きさの配列値 \(M[i, j]\) が勾配線に沿った両方の近傍の大きさより大きくない場合、\(M[i, j]\) は \(0\) に設定される。この工程は \(M[i, j]\) の勾配線の広がった尾根を、1ピクセル幅しかない尾根へと細くする。尾根の最も高い値は非極大抑圧された大きさの中に保持されている。
\[
N[i,j]=nms(M[i,j],\zeta[i,j]) \tag{5.49}
\]
が非極大抑圧の工程を表すとしよう。\(N[i, j]\) 内の非 \(0\) の値は画像輝度における階段状変化のコントラスト量に対応する。エッジ検出の第一ステップとして平滑化が実行されているにもかかわらず、非極大抑圧された大きさ画像 \(N[i, j]\) にはノイズや細かなテクスチャによって生じた偽のエッジの断片が多く含まれるであろう。偽エッジ断片のコントラストは低い。
</p>
<p>
<strong>閾値処理(Thresholding)</strong><br>
非極大抑圧された勾配の大きさの中の偽エッジ断片の数を減らすために使われる一般的な手続きは、\(N[i, j]\)に閾値を適用するということである。閾値よりも小さい値はすべて \(0\) に変更される。非極大抑圧された大きさに閾値を適用した結果は、画像 \(I[i, j]\) 内で検出されたエッジの配列になる。閾値τが低すぎたために尚、いくらかの偽エッジがあるかもしれない(偽陽性 false positive)し、影によりエッジのコントラストが弱められたり、閾値τが高すぎたりによって本当の輪郭の一部が見逃されるかもしれない(偽陰性 false negative)。適正な閾値を選ぶことは困難であり、試行錯誤を伴う。もっと効果的な閾値処理手法は2つの閾値を使う。
</p>
<p>
　二重閾値処理アルゴリズムは非極大抑圧された画像と \(N[i ,j]\) を受け取り、\(τ_2\approx2τ_1\) となる2つの閾値 \(τ_1\) と \(τ_2\) を適用し、閾値処理された2つのエッジ画像 \(T_1[i, j]\) と \(T_2[i, j]\) を生成する。画像 \(T_2\) は大きい閾値を使って形成されたので含まれる偽エッジは少ない;しかし \(T_2\) は(偽陰性が多すぎるため)輪郭に隙間があるかもしれない。二重閾値処理アルゴリズムは \(T_2\) 内のエッジを輪郭へと連結する。輪郭の終端に到達した場合、アルゴリズムは輪郭に連結できるエッジを探して、その場所の8近傍の \(T_1\) を参照する。このアルゴリズムは隙間が \(T_2\) 内のエッジに橋渡しされるまで、\(T_1\) からエッジを集め続ける。このアルゴリズムは閾値処理や閾値選択に関するいくらかの問題の解決の副産物としてエッジ連結を実行している。Cannyエッジ検出アルゴリズムをアルゴリズム5.1に概説する。
</p>
<p>
<strong>アルゴリズム5.1　Cannyエッジ検出</strong>
<div class="styleBullet">
<ul>
<li>1.　ガウス・フィルタを使って画像を平滑化する</li>
<li>2.　偏導関数の階差近似を使って勾配の大きさと方法を計算する</li>
<li>3.　勾配の大きさに対して非極大抑圧を適用する</li>
<li>4.　エッジを検出、連結するため二重閾値処理アルゴリズムを使う</li>
</ul>
</div>
</p>
<p>
　本節で紹介したエッジ検出アルゴリズムをいくつかのテスト画像に実行している。図5.22に連結棒の画像を示す。図5.22のテスト画像に対して、本節で概説したエッジ検出アルゴリズムを適用した結果を図5.23と図5.24に示す。図5.23では勾配を計算する前の画像平滑化に \(7×7\) ガウス・フィルタが使われている:　図5.24では \(31×31\) ガウス・フィルタが使われている。より小さいフィルタ・サイズに対する勾配の大きさの非極大抑圧はエッジの細部では優れた結果を示しているが、ノイズや細かなテクスチャによる不要なエッジ断片に悩まされている。後者のフィルタ・サイズでは、不要なエッジ断片は少ないが、エッジの細部の多くが失われている。これはエッジ定位とノイズ耐性の間のトレードオフを説明している。
</p>
<center><img src="images/fig5_22.png"></center>
<p>
<center>図5.22　連結棒のテスト画像。画像はReticon \(256×256\) エリアCCDカメラで取り込まれた</center>
</p>
<center><img src="images/fig5_23.png"></center>
<p>
図5.23　図5.22のテスト画像に \(7×7\) ガウス・フィルタを適用したエッジ検出結果。図の(a)はガウス平滑フィルタを使った平滑後に勾配近似を計算し、非極大を抑圧した結果のグレイ・レベル画像である。ノイズと細かなテクスチャによる弱いエッジ断片ははっきりとは現れていない。(b)は(a)から \(0\) より大きいすべてのピクセルを黒で描いたものである。このプロットはエッジ検出の結果には存在するが、結果のグレイ・レベル表示でははっきりと現れない弱いエッジ断片を示している。
</p>
<center><img src="images/fig5_24.png"></center>
<p>
図5.24　図5.22のテスト画像にエッジ検出を適用した結果。画像の平滑化に \(31×31\) ガウス・フィルタが使われ、その後で勾配近似の計算、非極大抑圧が続く。(a)は非極大抑圧された結果をグレイ値画像で示している。強い平滑フィルタがいかにエッジを丸めているかに注目。(b)はすべてのエッジ断片を示した結果を描いている。
</p>
<h2>5.7　サブピクセル位置推定(Subpixel Location Estimation)</h2>
<p>
多くの応用では、ピクセル間の間隔よりも細かい(サブピクセル解像度の)エッジ位置の推定を必要とする。勾配アルゴリズムと二次のエッジ検出アルゴリズムに対してサブピクセル解像度を得る方法は非常に異なっており別々に検討する。
</p>
<p>
　先ず、ガウシアンのラプラシアンの様な二次エッジ検出器の出力を考えよう。エッジはピクセル間の0交差によって示される。原理上、エッジ位置は線形補間を使ってサブピクセル解像度で計算できる。実際には。二次エッジ検出手法の出力は、ガウシアンの事前平滑を使ったとしても、正確な結果を与えるために単純に補間するにはノイズが多すぎる。
</p>
<p>
　勾配ベースの手法を使ってエッジ検出後にエッジ位置をサブピクセル解像度で得ることは現実的で効率的でもある。理想的な階段状エッジにガウス平滑フィルタと一次導関数を適用した結果は、平滑化に使ったガウス・フィルタと全く同じ形の断面になる。階段状エッジが理想的ではなく、あるレベルから別のレベルに徐々に移行する場合、ガウス平滑化と一次導関数の結果は広がったガウス分布で近似することができる。
</p>
<p>
　正規分布から取り出した一組の測定値を考えてみよう。釣り鐘型曲線の中央は、正規分布の平均値に対応し、それは測定値を平均することで推定できる。今度は生の測定値そのものではなく、測定値のヒストグラムが利用できるすべての情報であると仮定しよう。平均は、ヒストグラム・バケツの中央の値の、各バケツのエントリー数で重みづけされた和をヒストグラムの面積で割ることで推定できる。類推により、エッジの位置はガウス・エッジ検出器の出力の断面に沿って平均することにより、サブピクセル解像度で推定することができる。サブピクセル解像度でエッジ位置を計算するため、勾配の大きさが閾値を下回るまで、エッジの両側で勾配方向に沿ってガウシアン・エッジ検出器の出力(非極大抑圧は含めない)の大きさのサンプルをとる。勾配の大きさのサンプル \(g_i\) を、勾配に沿って位置 \(d_i\) の加重和を計算するための重みとして使う。勾配方向に沿ったエッジ位置のサブピクセル補正は以下の様に与えられる。
\[
\delta d=\frac{\sum\limits_{i=1}^ng_id_i}{\sum\limits_{i=1}^ng_i} \tag{5.50}
\]
ここで \(d_i\) はエッジが検出されたピクセルから勾配に沿って測ったピクセルの距離であり、\(g_i\) は勾配の大きさである。
</p>
<p>
　恐らく同じくらい効果的でより単純なアルゴリズムは、ガウシアン・エッジ検出器の勾配の大きさの一次モーメントの計算を適用することで、エッジが検出されたピクセルとの相対でエッジ位置 \((δx, δy)\) をサブピクセル解像度で計算することである。エッジ位置のより正確な推定を与えるためにピクセル座標に補正を加えることができる。
</p>
<p>
　勾配の大きさの断面に沿った平均を計算するアルゴリズムはより複雑ではあるが、その断面は統計技法を使った理想的な断面に匹敵すると言う利点があり、比較の結果はエッジ検出の基準として使うことができる。断面がガウス分布に近くないのであれば、そのエッジは理想的な階段モデルには対応しない。その場合には、本節で説明した技法を使ってエッジ位置を正確に推定することは不可能かもしれない。
</p>
<p>
　12章で画像の座標系を校正する方法を紹介する。ピクセル \([i, j]\) の整数座標がカメラの画像平面内の座標 \((x, y)\) にマップできる。画像平面内のエッジの正確な位置を得るために、上述のサブピクセル解像度でエッジ位置を推定する方法のいずれかによる補正がピクセルの \((x, y)\) 座標に加えられる。この正確な、校正された値が、測定された特徴の寸法として必要とされるものである。
</p>
<h2>5.8 エッジ検出器の性能</h2>
<p>
エッジ検出器の性能を評価するための計測がAbdouとPratt[文献1]、DeMicheli、Caprile、Torre[文献66]により定式化されている。エッジ検出器の性能を検討するための基準としては以下の様なものが含まれる
<div class="styleBullet">
<ul>
<li>1.　偽エッジの確率</li>
<li>2.　エッジ消失の確率</li>
<li>3.　推定エッジ角度の誤差</li>
<li>4.　本当のエッジと推定エッジの自乗平均距離</li>
<li>5.　エッジや、角・分岐といったその他特徴の歪に対する許容度</li>
</ul>
</div>
</p>
<p>
最初の2つの基準はエッジ検出器としてのアルゴリズムの性能に関する。続く2つの基準はエッジの位置や角度の推定器としてのアルゴリズムの性能に関する。最後の基準は、アルゴリズムの定式化に使われる理想的なモデルから逸脱したエッジに対する、エッジ・アルゴリズムの許容度に関する。
</p>
<h3>5.8.1　性能評価方法</h3>
<p>
エッジ検出器の性能は2つのステージで評価できる:　偽エッジ、エッジ消失の数を数えるステージと、推定された位置や方向の分散(または誤差分布)を測定するステージである。
</p>
<p>
　テスト・ケースとして、例えば境界の輪郭が線分でモデル化される塗りつぶされた矩形であるとか、間隔が既知である塗りつぶされた2つの矩形であるとかの単純な数式を使った曲線でモデル化できる輪郭沿ってエッジがどこに存在するかが既知である合成画像を選択する。オリジナルの(合成された)画像を使ってエッジ検出器の結果を比較することにより、正しいエッジ、偽エッジ、エッジ消失の数を数える。これは想像されるより大変な作業である。結果は閾値、平滑フィルタ・サイズ、エッジとその他要因との干渉により変わる。ノイズも平滑化もエッジ間の干渉も加えていないテスト画像に対してエッジ検出器を動作させるのであれば、完全な組のエッジ(エッジ消失、偽エッジなし)を取得できるべきである。このエッジの組を比較の標準として使う。
</p>
<p>
　今度はエッジ消失や偽エッジを生み出すノイズや画像内の歪を加えたテスト・ケースからエッジを取得することを考える。テスト画像におけるエッジと標準のエッジの1：1の対応をユークリッド距離の基準に基づいて計算する。理想的には14.3節で紹介する画像の視差解析用の方法といった適正な照合アルゴリズムを使うべきである。標準のエッジとかけ離れたエッジは偽エッジである; 標準のエッジと近くで対になるエッジは正しい。この手続きの後、テスト・ケース内のエッジと対にならない標準内のエッジはエッジ消失である。
</p>
<p>
　この手続きはエッジの存在、不在を示す能力のみに基づいてテストしており、どれくらい正確にエッジ位置や方向を推定したかについては何も語らない。元のテスト画像を使って(上で計算された)正しいエッジの組の中のエッジの位置と方向を比較する。この比較はテスト・ケースのモデルが入手可能である必要がある。塗りつぶされた矩形の場合、モデルは矩形の辺を構成する線分である。エッジ位置と方向は場面の輪郭モデルの数学的記述を使って比較されなければならない。位置 \((x, y)\) を持つ各エッジに対して、この位置が真の位置からどれくらい離れているか？エッジの方向と真の曲線の方向の違いは何か？エッジ位置 \((x, y)\) は輪郭に沿った任意の位置に対応付けることができるが、輪郭に沿った最も点が対応点として使われ、エッジ点と最も近い点の距離が計算される。線分の場合、6.4節の公式を使う。分散を推定するため(付録Bの公式を参照)、位置誤りのヒストグラムから誤差分布を推定したり、自乗誤算の総和を \(n－1\)(\(n\) はエッジの数)で割って表にしたりする。エッジの方向誤差は、エッジ断片の方向と場面の輪郭をモデル化した曲線の法線の角度をエッジ点に最も近い点で評価したものと比較することで測定する。
</p>
<h3>5.8.2　性能指標(Figure of Merit)</h3>
<p>
エッジ検出器の性能を判断する一つの方法は、エッジ画像を見て主観的に性能を評価するというものである。とは言え、この方法は性能の客観的な尺度を提供しない。各種エッジ検出器の性能を量的に評価するため、制御された条件の下で相対性能を判断する手助けになり得る基準を定式化すべきである。エッジ検出器の応答を観察すると、誤りには3種類がある:
<div class="styleBullet">
<ul>
<li>• 妥当なエッジを見失う</li>
<li>• エッジの定位を誤る</li>
<li>• ノイズをエッジと分類する</li>
</ul>
</div>
</p>
<p>
</p>
<p>
　エッジ検出器の性能指標は、これら3つの誤りを考慮すべきである。その様な性能指標の一つがPrattの性能指標[文献196]と呼ばれるものである
\[
FM=\frac{1}{\max(I_A,I_I)}\sum_{i=1}^{I_A}\frac{1}{1+\alpha d_i^2} \tag{5.51}
\]
ここで \(I_A,I_I,d,α\) はそれぞれ、検出されたエッジ、理想エッジ、実際のエッジと理想エッジの距離、ずれたエッジにペナルティを課すのに使われる設計定数である。
</p>
<p>
　この指標はエッジ消失点、エッジ点の位置、偽エッジ点を伴うため、限定されたクラスの画像にしか適用できないことに注意してもらいたい。制御されたコントラストの機知のオブジェクトを既知の位置に生成できるなら、上の性能指標を使うことができる。画像にランダム・ノイズを導入することにより合成画像に対する性能を評価することが一般的に行われていることである。性能指標に対する信号ノイズ比をプロットすることで検出器の性能劣化が与えられる。
</p>
<h2>5.9　逐次手法(Sequential Method)</h2>
<p>
上で説明したすべてのエッジ検出器は本来パラレルである: 局所的な情報を使って単一のピクセルに適用することができ、他のピクセルの結果に依存しない。実際にはその様なエッジ検出器の性能はエッジ消失が多すぎて受け入れられない。その様な検出器で検出されたエッジはオブジェクトの境界を形成するために連結されなければならない。エッジ消失は境界に切れ目を生じる。エッジ検出とエッジ連結の性能を改善する方法がいくつか提案されている。その様な手法にはエッジ追跡(edge following)、緩和法(relaxation)、境界追跡(boundary tracking)がある。緩和法について後の章で説明する。
</p>
<p>
　エッジ追跡は、エッジ検出器の性能を改善するためにエッジ点の近傍からの情報を使おうと試みる。この手法は単純なエッジ検出器の応答から薄いエッジも使おうとするかもしれない。基本的な手法はエッジ点がその近傍を調べるということである。エッジの方向が近傍の方向と適合するなら、エッジは連結される; 適合しないエッジは除去され、広い近傍を調べることで消失したエッジを埋めることができるかもしれない。
</p>
<p>
　エッジ追跡アルゴリズムはオブジェクトの境界を追跡するための開始点として使うため、強いエッジを探して画像を走査する。適正な方向にエッジを拡張するために、エッジの方向に依存してエッジ検出器が適用される。図5.25に示す様に、バックトラック(引き返し)ありやバックトラックなしで追跡捜査が実装されるかもしれない。この手法を使って、非常に弱いエッジ・セグメントでさえ検出できる場合がある。
</p>
<center><img src="images/fig5_25.png"></center>
<p>
<center>図5.25　エッジ追跡の図説</center>
</p>
<h2>5.10　線(エッジ)検出</h2>
<p>
重要な特徴である。線はすぐ近くにあり平滑フィルタの幅より狭い距離しかはない反対極性の2つのエッジとしてモデル化することができる。
</p>
<p>
　エッジ検出フィルタは階段状エッジに応答する様に設計されており、線に対して意味のある応答を提供しない。線を検出するためには別のアルゴリズムを使わなければならず、この線検出アルゴリズムは階段状エッジに対して意味のある応答は提供しない。マシン・ビジョンにおける未解決の問題の一つは、単一システムでどの様にエッジ検出と線検出を組み合わせるかというものである。
</p>
<p>
　線はCannyアルゴリズムの修正バージョンを使って検出できる: 勾配の大きさの代わりに平滑画像に非極大抑圧を実行する。線は階段の導関数なので、Cannyアルゴリズムにおける導関数ステップは不要である。
</p>
    </body>
</html>